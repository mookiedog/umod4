name: PyInstaller Diagnostics

on:
  workflow_dispatch:  # Allow manual triggering for testing
  push:
    branches:
      - main
    paths:
      - 'tools/logtools/**'
      - '.github/workflows/visualizer-release.yml'

jobs:
  diagnose-build:
    name: Diagnose ${{ matrix.os }} Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            artifact_name: DataVisualizer.exe
            shell: pwsh
          - os: ubuntu-latest
            artifact_name: DataVisualizer
            shell: bash

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install pyinstaller PyQt6 pyqtgraph numpy pandas h5py
          python -m pip install pyinstxtractor-ng

      - name: Create diagnostic startup wrapper
        shell: bash
        run: |
          cat > tools/logtools/viz/diagnostic_wrapper.py << 'EOF'
          """Diagnostic wrapper to check module availability at runtime"""
          import sys
          import os
          import importlib.util

          def check_bundled_modules():
              """Verify critical modules are accessible"""
              print("=" * 70)
              print("DIAGNOSTIC INFORMATION")
              print("=" * 70)
              print(f"Python version: {sys.version}")
              print(f"Python executable: {sys.executable}")
              print(f"sys.frozen: {getattr(sys, 'frozen', False)}")

              if getattr(sys, 'frozen', False):
                  print(f"Running as frozen app")
                  if hasattr(sys, '_MEIPASS'):
                      print(f"_MEIPASS: {sys._MEIPASS}")
                      print(f"Contents of _MEIPASS:")
                      try:
                          for item in sorted(os.listdir(sys._MEIPASS)):
                              item_path = os.path.join(sys._MEIPASS, item)
                              if os.path.isdir(item_path):
                                  print(f"  [DIR]  {item}/")
                              else:
                                  size = os.path.getsize(item_path)
                                  print(f"  [FILE] {item} ({size} bytes)")
                      except Exception as e:
                          print(f"  Error listing _MEIPASS: {e}")

              print(f"\nsys.path:")
              for i, path in enumerate(sys.path):
                  print(f"  [{i}] {path}")

              print(f"\n__file__: {__file__}")
              print(f"Current working directory: {os.getcwd()}")

              # Critical modules to check
              critical_modules = [
                  'decodelog',
                  'conversions',
                  'stream_config',
                  'viz_components',
                  'viz_components.config',
                  'viz_components.widgets',
                  'viz_components.utils',
                  'viz_components.rendering',
                  'viz_components.data',
                  'viz_components.navigation',
              ]

              print("\n" + "=" * 70)
              print("MODULE AVAILABILITY CHECK")
              print("=" * 70)

              missing = []
              for mod in critical_modules:
                  try:
                      spec = importlib.util.find_spec(mod)
                      if spec:
                          print(f"✓ {mod:40s} -> {spec.origin}")
                      else:
                          print(f"✗ {mod:40s} -> NOT FOUND (spec is None)")
                          missing.append(mod)
                  except (ImportError, ModuleNotFoundError) as e:
                      print(f"✗ {mod:40s} -> ERROR: {e}")
                      missing.append(mod)

              print("=" * 70)
              if missing:
                  print(f"MISSING MODULES: {len(missing)}")
                  for mod in missing:
                      print(f"  - {mod}")
                  print("=" * 70)
                  return False
              else:
                  print("ALL MODULES FOUND")
                  print("=" * 70)
                  return True

          if __name__ == '__main__':
              success = check_bundled_modules()
              sys.exit(0 if success else 1)
          EOF

      - name: Build with PyInstaller
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "macOS" ]; then
            SEP=":"
          else
            SEP=":"
          fi

          python -m PyInstaller --log-level DEBUG \
            --onefile --windowed \
            --add-data "tools/logtools/viz/stream_config.py${SEP}." \
            --add-data "tools/logtools/viz/stream_config.yaml${SEP}." \
            --add-data "tools/logtools/viz/viz_components${SEP}viz_components" \
            --add-data "tools/logtools/decoder/decodelog.py${SEP}." \
            --add-data "tools/logtools/decoder/conversions.py${SEP}." \
            --name "DataVisualizer" \
            --clean \
            tools/logtools/viz/viz.py 2>&1 | tee pyinstaller_build.log

      - name: Build diagnostic executable
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "macOS" ]; then
            SEP=":"
          else
            SEP=":"
          fi

          python -m PyInstaller --log-level DEBUG \
            --onefile \
            --add-data "tools/logtools/viz/stream_config.py${SEP}." \
            --add-data "tools/logtools/viz/stream_config.yaml${SEP}." \
            --add-data "tools/logtools/viz/viz_components${SEP}viz_components" \
            --add-data "tools/logtools/decoder/decodelog.py${SEP}." \
            --add-data "tools/logtools/decoder/conversions.py${SEP}." \
            --name "Diagnostics" \
            --clean \
            tools/logtools/viz/diagnostic_wrapper.py 2>&1 | tee pyinstaller_diagnostic_build.log

      - name: Analyze PyInstaller warnings and errors
        shell: bash
        run: |
          echo "Analyzing PyInstaller build log for issues..."
          echo "=============================================="
          echo ""
          echo "WARNINGS:"
          grep -i "warning" pyinstaller_build.log || echo "No warnings found"
          echo ""
          echo "ERRORS:"
          grep -i "error" pyinstaller_build.log || echo "No errors found"
          echo ""
          echo "NOT FOUND:"
          grep -i "not found" pyinstaller_build.log || echo "No 'not found' messages"
          echo ""
          echo "MISSING:"
          grep -i "missing" pyinstaller_build.log || echo "No 'missing' messages"

      - name: Extract and analyze spec file
        shell: bash
        run: |
          echo "Analyzing generated spec file..."
          echo "================================="
          cat DataVisualizer.spec
          echo ""
          echo "Checking for our modules in Analysis section..."
          grep -A 20 "Analysis(" DataVisualizer.spec || true

      - name: Run diagnostic executable
        shell: bash
        run: |
          if [ "$RUNNER_OS" == "Windows" ]; then
            ./dist/Diagnostics.exe > diagnostic_runtime.log 2>&1 || true
          else
            ./dist/Diagnostics > diagnostic_runtime.log 2>&1 || true
          fi
          cat diagnostic_runtime.log

      - name: Extract executable contents (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Write-Host "Extracting Windows executable contents..."
          pyinstxtractor dist/DataVisualizer.exe

          Write-Host "`nContents of extracted archive:"
          Get-ChildItem -Recurse "DataVisualizer.exe_extracted" | ForEach-Object {
              $indent = "  " * ($_.FullName.Split([IO.Path]::DirectorySeparatorChar).Count - "DataVisualizer.exe_extracted".Split([IO.Path]::DirectorySeparatorChar).Count - 1)
              if ($_.PSIsContainer) {
                  Write-Host "$indent[DIR]  $($_.Name)/"
              } else {
                  $size = $_.Length
                  Write-Host "$indent[FILE] $($_.Name) ($size bytes)"
              }
          }

          Write-Host "`nSearching for our modules..."
          Get-ChildItem -Recurse "DataVisualizer.exe_extracted" -Filter "*decodelog*" | ForEach-Object {
              Write-Host "Found: $($_.FullName)"
          }
          Get-ChildItem -Recurse "DataVisualizer.exe_extracted" -Filter "*conversions*" | ForEach-Object {
              Write-Host "Found: $($_.FullName)"
          }
          Get-ChildItem -Recurse "DataVisualizer.exe_extracted" -Filter "*viz_components*" | ForEach-Object {
              Write-Host "Found: $($_.FullName)"
          }
          Get-ChildItem -Recurse "DataVisualizer.exe_extracted" -Filter "*stream_config*" | ForEach-Object {
              Write-Host "Found: $($_.FullName)"
          }

          # Save directory listing to file
          Get-ChildItem -Recurse "DataVisualizer.exe_extracted" | Out-File -FilePath extracted_contents_windows.txt

      - name: Extract executable contents (Linux)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          echo "Extracting $RUNNER_OS executable contents..."
          pyinstxtractor dist/DataVisualizer

          echo ""
          echo "Contents of extracted archive:"
          find DataVisualizer_extracted -type f -o -type d | sort | while read path; do
              if [ -d "$path" ]; then
                  echo "[DIR]  $path/"
              else
                  size=$(stat -f%z "$path" 2>/dev/null || stat -c%s "$path" 2>/dev/null)
                  echo "[FILE] $path ($size bytes)"
              fi
          done

          echo ""
          echo "Searching for our modules..."
          find DataVisualizer_extracted -name "*decodelog*" -o -name "*conversions*" -o -name "*viz_components*" -o -name "*stream_config*"

          # Save directory listing to file
          find DataVisualizer_extracted -type f -o -type d | sort > extracted_contents_${RUNNER_OS}.txt

      - name: Compare with source files
        shell: bash
        run: |
          echo "Source files that should be bundled:"
          echo "====================================="
          echo ""
          echo "Decoder modules:"
          ls -lh tools/logtools/decoder/*.py
          echo ""
          echo "Viz components:"
          find tools/logtools/viz/viz_components -name "*.py" -exec ls -lh {} \;
          echo ""
          echo "Config files:"
          ls -lh tools/logtools/viz/stream_config.*

      - name: Generate diagnostic report
        shell: bash
        run: |
          cat > diagnostic_report_${{ runner.os }}.md << 'EOF'
          # PyInstaller Diagnostic Report - ${{ runner.os }}

          ## Build Information
          - OS: ${{ runner.os }}
          - Python Version: 3.10
          - PyInstaller Version: $(pip show pyinstaller | grep Version | cut -d' ' -f2)
          - Build Date: $(date)

          ## Files Generated
          - PyInstaller build log: pyinstaller_build.log
          - PyInstaller diagnostic build log: pyinstaller_diagnostic_build.log
          - Spec file: DataVisualizer.spec
          - Diagnostic spec file: Diagnostics.spec
          - Runtime diagnostic log: diagnostic_runtime.log
          - Extracted contents listing: extracted_contents_${{ runner.os }}.txt

          ## Quick Analysis

          ### Build Warnings/Errors
          See pyinstaller_build.log for full details.

          ### Runtime Module Check
          See diagnostic_runtime.log for module availability at runtime.

          ### Extracted Contents
          See extracted_contents_${{ runner.os }}.txt for full file listing.

          ## Key Files to Check

          1. Is decodelog.pyc present in extracted archive?
          2. Is conversions.pyc present in extracted archive?
          3. Is viz_components/ directory present with all submodules?
          4. Is stream_config.py present?
          5. Is stream_config.yaml present?

          ## Next Steps

          If modules are missing:
          1. Check spec file Analysis() section for pathex and hiddenimports
          2. Check build log for "not found" or "missing" messages
          3. Verify --add-data paths are correct for the OS
          4. Consider using --paths to add tools/logtools to module search path
          5. Consider adding explicit hiddenimports for local modules

          EOF

          cat diagnostic_report_${{ runner.os }}.md

      - name: Upload all diagnostic artifacts
        uses: actions/upload-artifact@v4
        with:
          name: diagnostics-${{ runner.os }}
          path: |
            pyinstaller_build.log
            pyinstaller_diagnostic_build.log
            *.spec
            diagnostic_runtime.log
            extracted_contents_*.txt
            DataVisualizer.exe_extracted/**
            DataVisualizer_extracted/**
            diagnostic_report_*.md

  compare-builds:
    name: Compare Platform Builds
    needs: diagnose-build
    runs-on: ubuntu-latest

    steps:
      - name: Download all diagnostic artifacts
        uses: actions/download-artifact@v4
        with:
          path: diagnostics

      - name: Generate comparison report
        shell: bash
        run: |
          cat > comparison_report.md << 'EOF'
          # Cross-Platform PyInstaller Comparison

          ## Overview
          This report compares the PyInstaller builds across Windows and Linux
          to identify platform-specific issues.

          ## Artifacts Downloaded
          EOF

          find diagnostics -type f | sort >> comparison_report.md

          echo "" >> comparison_report.md
          echo "## Module Presence Comparison" >> comparison_report.md
          echo "" >> comparison_report.md
          echo "### Windows" >> comparison_report.md
          if [ -f diagnostics/diagnostics-Windows/diagnostic_runtime.log ]; then
            grep -A 20 "MODULE AVAILABILITY CHECK" diagnostics/diagnostics-Windows/diagnostic_runtime.log >> comparison_report.md || echo "No module check found" >> comparison_report.md
          else
            echo "Windows diagnostic log not found" >> comparison_report.md
          fi

          echo "" >> comparison_report.md
          echo "### Linux" >> comparison_report.md
          if [ -f diagnostics/diagnostics-Linux/diagnostic_runtime.log ]; then
            grep -A 20 "MODULE AVAILABILITY CHECK" diagnostics/diagnostics-Linux/diagnostic_runtime.log >> comparison_report.md || echo "No module check found" >> comparison_report.md
          else
            echo "Linux diagnostic log not found" >> comparison_report.md
          fi

          echo "" >> comparison_report.md
          echo "## Recommendations" >> comparison_report.md
          echo "" >> comparison_report.md
          echo "Compare the module availability sections above:" >> comparison_report.md
          echo "- If Linux shows ✓ but Windows shows ✗, the issue is Windows-specific" >> comparison_report.md
          echo "- Check extracted_contents_*.txt files to see what was actually bundled" >> comparison_report.md
          echo "- Review spec files to ensure --add-data paths use correct separators" >> comparison_report.md
          echo "- Consider platform-specific fixes in the build workflow" >> comparison_report.md

          cat comparison_report.md

      - name: Upload comparison report
        uses: actions/upload-artifact@v4
        with:
          name: comparison-report
          path: comparison_report.md
