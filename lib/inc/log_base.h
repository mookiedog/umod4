#if !defined LOG_BASE_H
#define LOG_BASE_H

// IMPORTANT: This file is included by .S and .c files and will be
// processed by Python scripts, so it must ONLY contain #defines!

// The binary logs generated by the umod4 system take the form of 
// 8 bits of LOGID information followed by 0 or more bytes of data.
// The amount of data depends on the specific LOGID byte.
// To help humans and tools decode LOGID information, the system
// defines items to be logged using a naming convention.

// Naming Convention
//
// The system will define a set of LOGID values that each subsystem can use to emit log records.
// At the moment, there are 4 subsystems:
//    1. GEN    general subsystem, not necessarily tied to any specific subsystem
//    2. ECU    the HC11 ECU is the source of these log messages
//    3. EP     the EP is the source of these log messages
//    4. WP     the WP is the source of these log messages

// Each subsystem will include this file to find out the subspace of the LOGIDs that they can use
// within the 256-entry LOGID space. The _BASE and _LAST symbols define a subsystem's start and end offsets
// assigned to them within the LOGID space. These spaces will not overlap.

// Each log event is represented by a single macro that encodes both its unique ID and data type:
//
//    LOGID_<subsystem>_<name>_TYPE_<typeID>
//
// The macro expands to an 8‑bit value that uniquely identifies the event.
// The suffix _TYPE_* (e.g., _TYPE_U8, _TYPE_TS) is merely part of the naming convention
// and indicates what kind of data follows the ID.
// Allowable types are defined below.
//
// A matching LOGID_<subsystem>_<name>_DLEN macro must be defined to specify how many bytes of payload accompany the ID.

// The system may optionally define literal constants to help decode raw data associated with a specific LOGID.
// If present, the naming convention is chosen to make sure that literals are to be associated with specific LOGID values:
//    LOGID_<subsystem>_<name>_VAL_<constant_name>
//
// Data Types
//
// The data associated with each LOGID is typed. The type information will be encoded in the TYPE name
// by appending the various type ID strings 'XX' shown below using the general form LOGID_<subsystem>_<name>_TYPE_XX:
//
// *** WARNING:
// *** If you make changes to the naming convention, you MUST update the generate_encoder.py utility
// *** to properly generate the logEncoder data structure!!!
// ***
//
//    _I16  int16   Signed 16-bit int
//    _U16  uint16  Unsigned 16-bit int
//    _TS   uint16  A Timestamp marker.
//                  Timestamps are derived from a free-running 16-bit counter in the ECU with a precision of 2 uSec per tick.
//                  All untimestamped events in the log before this _TS event must have occurred before this time.
//                  All untimestamped events in the log after this _TS event must have occurred after this time
//                  It is the responsibility of a log decoder to properly track 16-bit rollover events
//    _PTS  uint16  A 'prescriptive' timestamp associated with an event.
//                  Prescriptive timestamps can describe events that will occur in the future (like when an injector pulse is scheduled to begin)
//                  or things in the past (like reporting the time at which a spark detect event was actually observed)
//    _I8   int8    Signed 8-bit int
//    _U8   uint8   Unsigned 8-bit int
//    _B    bool    (0 means false, and non-zero means true)
//    _xPy  fixPt   A general fixed point form where x digits in front of an assumed decimal point with y digits after it.
//                  Examples:
//                      LOGID_ECU_FOO_TYPE_0P8  would represent an 8-bit 0.8 fixed point value
//                      LOGID_ECU_FOO_TYPE_4P12 would represent a 16-bit 4.12 fixed point value
//    _V    void    Indicates that the log entry carries no useful data
//                  NOTE: if _DLEN > 0, DLEN bytes will exist in the log data but must be discarded by the decoder
//    _C    char    Next character of a string
//                  The string can be considered complete when this character has the value NULL (0x00).
//                  Note: Turning _C characters into a string implies stateful processing by a decoder:
//                      The first _C LOGID observed will initialize a string buffer and store the first character in it.
//                      Subsequent _C LOGIDs will append the new character to the existing string buffer.
//                      When a _C LOGID is observed with a NULL character, the string is complete for decoding purposes. 
//
// A complete example of the naming convention follows.
//
// Definition of symbols:
//     Assume that the ECU wants to log that it is performing an unexpected CPU event, specifically, an RTI event.
//
// #define LOGID_ECU_CPU_EVENT_TYPE_U8      ((LOGID_ECU_BASE) + 0x00)   // Assign this log event its own ID value relative to the start of the ECU subspace
// #define LOGID_ECU_CPU_EVENT_DLEN         1                           // Type U8 indicates that a single byte will follow the LOGID_ECU_CPU_EVENT_TYPE_U8 byte in the log
// Value constants for LOGID_ECU_CPU_EVENT_TYPE_U8:
// #define     LOGID_ECU_CPU_EVENT_VAL_RTI             (0x0)
// #define     LOGID_ECU_CPU_EVENT_VAL_IRQ             (0x1)

// Usage of symbols (using HC11 assembly language as an example)
//      ldaA    #LOGID_ECU_CPU_EVENT_VAL_RTI        ; LOGID_ECU_CPU_EVENT_TYPE_U8 will fit in an 8-bit register
//      staA    LW + LOGID_ECU_CPU_EVENT_TYPE_U8



// We start by defining how the 256 bytes of the LOGID space gets split among
// among the subsystems: GEN (general use), ECU, EP, and WP.

// The first 0x10 locations from [0x00..0x0F] are reserved for general information.
#define     LOGID_GEN_BASE                          (0x00)
#define     LOGID_GEN_LAST                          (0x0F)

// The ECU is by far the biggest source of log events.
// Define the range of IDs assigned to the ECU data stream:
#define     LOGID_ECU_BASE                          (0x10)
#define     LOGID_ECU_LAST                          (0xCF)

// Define the range of IDs assigned to the EP:
#define     LOGID_EP_BASE                           (0xD0)
#define     LOGID_EP_LAST                           (0xDF)

// Define the range of IDs assigned to the WP:
#define     LOGID_WP_BASE                           (0xE0)
#define     LOGID_WP_LAST                           (0xFF)


// Define the LOGIDs used for general information:

// Defining a zero byte as being usused with no data lets us skip a sequence of zero bytes, should that prove useful
#define     LOGID_GEN_UNUSED_V                      ((LOGID_GEN_BASE) + 0x00)
#define     LOGID_GEN_UNUSED_DLEN                   0

// Logging version numbers that the logging subsystems will be using are part of the
// general subsystem, not the specific subsystems. In theory, this would allow
// the subsystems to even change their base addresses because that could be baked
// into their version numbers.
#define     LOGID_GEN_ECU_LOG_VER_TYPE_U8           ((LOGID_GEN_BASE) + 0x01)
#define     LOGID_GEN_ECU_LOG_VER_DLEN              1

#define     LOGID_GEN_EP_LOG_VER_TYPE_U8            ((LOGID_GEN_BASE) + 0x02)
#define     LOGID_GEN_EP_LOG_VER_DLEN               1

#define     LOGID_GEN_WP_LOG_VER_TYPE_U8            ((LOGID_GEN_BASE) + 0x03)
#define     LOGID_GEN_WP_LOG_VER_DLEN               1

#endif
