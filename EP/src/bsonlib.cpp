#include "bsonlib.h"
#include <string.h>
#include <stdio.h>

static uint32_t dbg = 0;

// Generated by the linker:
extern uint32_t __BSON_IMAGE_PARTITION_START_ADDR;

// All BSON ints are little-endian.
uint32_t Bson::read_unaligned_uint32(const uint8_t* p)
{
    uint32_t result = 0;
    for (int i=0; i<4; i++) {
        result |= (*p)<<(8*i);
        p++;
    }
    //printf("%s: returning 0x%08X\n", __FUNCTION__, result);
    return result;
}

int32_t Bson::elementLength_bytes(uint8_t* elementP)
{
    // The first byte of an element holds the type of the value field (BSON_TYPE_xxx)
    int8_t valueType_id = (int8_t)*elementP;

    // The byte immediately after the elementValueType is the start of the element name
    const char* elementName = (const char*)elementP+1;

    // Create a pointer to the element's value field. It will begin after
    // the null byte that terminates the C-string elementName field.
    // Remember to add 1 to account for the null byte.
    const uint8_t* elementValueP = (uint8_t*)elementName + strlen(elementName) + 1;

    // Calculate the size so far
    int32_t size = elementValueP - elementP;

    // Now that we know where the field starts we are ready to account for its size.

    // The valueSize is based on the data type of the BSON value field:
    switch (valueType_id) {
        case BSON_TYPE_MINKEY:
        case BSON_TYPE_MAXKEY:
            // No extra data present
            break;

        case BSON_TYPE_DOUBLE:
            size += sizeof(double);
            break;

        case BSON_TYPE_UTF8:
        case BSON_TYPE_JS_CODE:
        case BSON_TYPE_SYMBOL:      // deprecated
            // All strings start with their length as a 4-byte integer which needs to be accounted for:
                size += 4;
            // Intentional fall through!
        case BSON_TYPE_EMBEDDED_DOC:
        case BSON_TYPE_ARRAY:
            // For EMBEDDED_DOC or ARRAY types, the int32 holding the document length is already accounted for in the document length
            // In all cases, we now add the encoded size of the data to our running total
            size += read_unaligned_uint32(elementValueP);
            break;

        case BSON_TYPE_BINARY_DATA:
            // binary ::= int32 subtype (byte*)	Binary - The int32 is the number of bytes in the (byte*)
            size += sizeof(int32_t) + 1;                                // int32 + subtype byte
            size += (int32_t)read_unaligned_uint32(elementValueP);      // number of binary bytes
            break;

        case BSON_TYPE_UNDEFINED_VALUE:     // deprecated
            break;

        case BSON_TYPE_OBJECT_ID:
            size += 12;
            break;

        case BSON_TYPE_BOOLEAN:
            size += 1;
            break;

        case 10:    // null value
            break;

        case 11:    // regex
            {
                char* s1 = (char*)(elementValueP);
                uint32_t s1Len = strlen(s1);
                char* s2 = s1+strlen(s1)+1;
                uint32_t s2Len = strlen(s2);
                size += (s1Len + 1 + s2Len + 1);
            }
            break;

        case BSON_TYPE_DBPOINTER:   // deprecated
            // account for the length of the string
            {
                int32_t stringLen = (int32_t)read_unaligned_uint32(elementValueP);
                size += stringLen;
            }
            // account for the 4 bytes needed to hold the string length
            size += 4;              // int32 string length

            // account for the 12 bytes of DB Pointer data
            size += 12;
            break;

        case BSON_TYPE_JS_CODE_W_S:    // JavaScript code with scope â€” Deprecated
            // todo: for completeness, this could be added but this system never uses this deprecated data type.
            break;

        case BSON_TYPE_INT32:
            size += sizeof(int32_t);
            break;

        case BSON_TYPE_UTC_DATETIME:
        case BSON_TYPE_TIMESTAMP:
        case BSON_TYPE_INT64:
            size += sizeof(int64_t);
            break;

        case BSON_TYPE_FLOAT128:    // decimal 128-bit floating point
            // Calculate the number of bytes in a 128 bit value
            size += 128/8;
            break;

        default:
            // panic??
            break;
    }

    //printf("%s: the element named '%s' having BSON type %d is %d bytes long\n", __FUNCTION__, elementName, valueType_id, size);
    return size;
}

// Scan a BSON embedded doc looking for the specified elementName.
// The doc pointer needs to point to the first byte of the length of the embedded doc.
// Returns a pointer to the first byte of the element data matching the desired name
// i.e. to the data type of the element.
bool Bson::findElement(uint8_t* docP, const char* elementName, element_t &e)
{
    if (dbg) printf("%s: Begin search for '%s'\n", __FUNCTION__, elementName);
    int32_t docLen = (int32_t)read_unaligned_uint32(docP);
    uint8_t* elementListP = docP+4;

    // generate a pointer to the very last byte in the doc.
    uint8_t* docEndP = docP+docLen-1;
    if (*docEndP != 0x00) {
        if (dbg) printf("%s: ERR: document does not end with a zero byte!\n", __FUNCTION__);
    }
    else {
        if (dbg) printf("%s: Doc ends with zero byte!\n", __FUNCTION__);
    }
    while ((*elementListP != 0x00) && (elementListP < docEndP)) {
        e.elementP = elementListP;
        e.elementType = *elementListP;
        e.name = (char*)(elementListP+1);
        e.data = elementListP + 1 + strlen(e.name) + 1;

        if (dbg) printf("%s: Checking '%s' against e_name '%s', type %d\n", __FUNCTION__, elementName, e.name, e.elementType);

        if (0 == strcmp(elementName, e.name)) {
            if (dbg) printf("%s: found it!\n", __FUNCTION__);
            return(true);
        }

        // We need to skip over the value section of this element
        if (dbg) printf("%s: no match\n", __FUNCTION__);
        uint32_t skipCount = elementLength_bytes(e.elementP);
        elementListP += skipCount;
        if (dbg) printf("%s: Skipping %d bytes to next element\n", __FUNCTION__, skipCount);
    }

    if (dbg) printf("%s: returning FALSE\n", __FUNCTION__);
    return false;
}
