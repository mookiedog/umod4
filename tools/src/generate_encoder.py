#!/usr/bin/env python3

import argparse
import os
import sys

def parse_line(line):
    """Parse a line and extract symbol name and value if it matches the pattern."""
    # Pattern: symbol_name = expression_string # value
    # We're looking for lines with '=' and '#'
    if '=' not in line or '#' not in line:
        return None, None
    
    # Split by '#' to separate the value part
    parts = line.split('#')
    if len(parts) < 2:
        return None, None
    
    # Get the left side (symbol_name = expression_string)
    left_side = parts[0]
    # Get the right side (value)
    right_side = parts[1]
    
    # Extract symbol name from left side (before '=')
    if '=' not in left_side:
        return None, None
    
    symbol_name = left_side.split('=')[0].strip()
    
    # Only process symbols that start with LOGID_EP or LOGID_ECU
    if not (symbol_name.startswith('LOGID_EP') or symbol_name.startswith('LOGID_ECU') or symbol_name.startswith('LOGID_GEN_ECU') or symbol_name.startswith('LOGID_GEN_EP')):
        return None, None
    
    # Only process symbols with _TYPE_ in the name
    if '_TYPE_' not in symbol_name:
        return None, None
    
    # Extract value from right side
    value_str = right_side.strip().split()[0] if right_side.strip() else ""
    
    return symbol_name, value_str

def parse_hex_value(value_str):
    """Parse hex value and validate it's in range 0x00-0xFF."""
    try:
        # Check if it starts with 0x or 0X
        if not value_str.lower().startswith('0x'):
            return None
        
        value = int(value_str, 16)
        
        # Check range
        if value < 0x00 or value > 0xFF:
            return None
        
        return value
    except ValueError:
        return None

def write_header_file(header_path):
    """Write the header file with D_ constants and extern declaration."""
    with open(header_path, 'w') as f:
        f.write("// *************************************************************************************\n")
        f.write("// Autogenerated: Do Not Edit!!\n")
        f.write("\n")
        f.write("#ifndef LOG_ENCODER_H\n")
        f.write("#define LOG_ENCODER_H\n")
        f.write("\n")
        f.write("#include <stdint.h>\n")
        f.write("\n")
        f.write("#define D_BYTE 1\n")
        f.write("#define D_MSB  2\n")
        f.write("#define D_LSB  3\n")
        f.write("\n")
        f.write("extern uint8_t logEncoder[256];\n")
        f.write("\n")
        f.write("#endif // LOG_ENCODER_H\n")

def write_header_to_stdout():
    """Write the header file content to stdout."""
    print("// *************************************************************************************")
    print("// Autogenerated: Do Not Edit!!")
    print()
    print("#ifndef LOG_ENCODER_H")
    print("#define LOG_ENCODER_H")
    print()
    print("#include <stdint.h>")
    print()
    print("#define D_BYTE 1")
    print("#define D_MSB  2")
    print("#define D_LSB  3")
    print()
    print("extern uint8_t logEncoder[256];")
    print()
    print("#endif // LOG_ENCODER_H")
    print()

def main():
    parser = argparse.ArgumentParser(description='Generate C array from symbol definitions')
    parser.add_argument('-i', '--input', required=True, help='Input file')
    parser.add_argument('-o', '--output', help='Output file (default: stdout)')
    
    args = parser.parse_args()
    
    # Read and parse input file
    symbols = []
    errors = []
    
    try:
        with open(args.input, 'r') as f:
            for line_num, line in enumerate(f, 1):
                symbol_name, value_str = parse_line(line)
                
                if symbol_name is None:
                    continue  # Ignore this line
                
                value = parse_hex_value(value_str)
                
                if value is None:
                    errors.append(f"Line {line_num}: Invalid hex value '{value_str}' for symbol '{symbol_name}'")
                    continue
                
                symbols.append((symbol_name, value))
    
    except FileNotFoundError:
        print(f"Error: Input file '{args.input}' not found", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error reading input file: {e}", file=sys.stderr)
        sys.exit(1)
    
    # Check for type-specific constraints
    for symbol_name, value in symbols:
        if (symbol_name.endswith('_TYPE_I16') or 
            symbol_name.endswith('_TYPE_U16') or 
            symbol_name.endswith('_TYPE_TS')):
            if value % 2 != 0:
                errors.append(f"Error: Symbol '{symbol_name}' has odd value 0x{value:02X}, but must be even")
    
    # Report all errors
    if errors:
        for error in errors:
            print(error, file=sys.stderr)
        sys.exit(1)
    
    # Generate output entries
    entries = []
    
    for symbol_name, value in symbols:
        if (symbol_name.endswith('_TYPE_I16') or 
            symbol_name.endswith('_TYPE_U16') or 
            symbol_name.endswith('_TYPE_TS')):
            # Two-byte types
            entries.append((value, f"[0x{value:02X}] = D_MSB,", symbol_name))
            entries.append((value + 1, f"[0x{value + 1:02X}] = D_LSB,", symbol_name))
        else:
            # Single-byte types (anything else with _TYPE_ in the name)
            entries.append((value, f"[0x{value:02X}] = D_BYTE,", symbol_name))
    
    # Sort entries by value
    entries.sort(key=lambda x: x[0])
    
    # Determine header file path and name
    if args.output:
        # Get directory and base name of output file
        output_dir = os.path.dirname(args.output) or '.'
        output_base = os.path.splitext(os.path.basename(args.output))[0]
        header_path = os.path.join(output_dir, output_base + '.h')
        header_include = output_base + '.h'
        
        # Write header file
        write_header_file(header_path)
        
        # Open output file
        output_file = open(args.output, 'w')
    else:
        # Write header to stdout first
        write_header_to_stdout()
        output_file = sys.stdout
        header_include = "log_encoder.h"
    
    try:
        # Write C source file
        output_file.write("// *************************************************************************************\n")
        output_file.write("// Autogenerated: Do Not Edit!!\n")
        output_file.write("\n")
        output_file.write(f'#include "{header_include}"\n')
        output_file.write("\n")
        output_file.write("uint8_t logEncoder [256] = {\n")
        
        # Write array entries with comments aligned at column 25
        for _, code, comment in entries:
            # 4 spaces indent + code
            line_start = "    " + code
            padding = max(1, 25 - len(line_start))
            output_file.write(f"{line_start}{' ' * padding}// {comment}\n")
        
        # Write closing brace
        output_file.write("};\n")
    
    finally:
        if args.output:
            output_file.close()

if __name__ == '__main__':
    main()
