#!/usr/bin/env python3

# Decode logs generated by the umod4 system.
#
# To do this 'manually' to decode a log file, invoke this script as follows:
#
#    <path-to-decodelog.py> <binary-log-file-to-decode>
#
# example:
#    ~/projects/umod4/tools/src/decodelog.py ~/logs/log.17
#

import sys
import os
import math
import argparse

headingsPrinted = False
msb = 0
msb_id = -1

# Number of bytes to skip at the start before decoding the rest of the file
skipBytes = 0

def parse_skip_bytes(value):
    try:
        return int(value)
    except ValueError:
        raise argparse.ArgumentTypeError(f"skipBytes must be an integer, got '{value}'")

cr_ts = -1
fc_off = 0
rc_off = 0
map = -1
aap = -1
vm_V = -1
vta = -1
vtaPrev = -1
cr_ts_prev = -1
elapsed = -1
cridPrev = -1
crid = -1
epromIdString = ""
currentEpromId = epromIdString
rpm_avg = 0.0
secs=-1

fi_on = -1
ri_on = -1
ri_dur = 0
fi_dur = 0

showBinData = True
address = 0

# Track the max difference between the two methods of converting thermistor readings to temperatures
maxDiff = 0.0

import array as arr
rpm_hist = arr.array('d', [])

f=""

def decodeL000C(byte):
    if (byte & 0x80):
        print(f"Bad CAM,", end="")
    if (byte & 0x40):
        print(f"Bad CRANK,", end="")
    if (byte & 0x20):
        print(f"Bad MAP,", end="")
    if (byte & 0x10):
        print(f"Bad AN2,", end="")
    if (byte & 0x08):
        print(f"Bad VTA,", end="")
    if (byte & 0x04):
        print(f"Bad THW,", end="")
    if (byte & 0x02):
        print(f"Bad THA,", end="")
    if (byte & 0x01):
        print(f"Bad AAP", end="")
    print()

# Decoding L000D and L000F are identical. 
# L000D events can get "better" if the sensor comes back on-line,
# but L000F events are "sticky" until the ECU powers down again.
def decodeL000D(byte):
    if (byte & 0x80):
        print(f"?B7,", end="")
    if (byte & 0x40):
        print(f"?B6,", end="")
    if (byte & 0x20):
        print(f"?B5,", end="")
    if (byte & 0x10):
        print(f"Bad Rcoil1,", end="")
    if (byte & 0x08):
        print(f"Bad Rcoil2,", end="")
    if (byte & 0x04):
        print(f"Bad Fcoil1,", end="")
    if (byte & 0x02):
        print(f"Bad Fcoil2,", end="")
    if (byte & 0x01):
        print(f"Bad DON", end="")
    print()

# This function converts a raw 8-bit ADC reading of an Aprilia temperature sensor back to degrees C.
#
# An excellent calculator of NTC thermistor response can be found here:
#   https://www.thinksrs.com/downloads/programs/therm%20calc/ntccalibrator/ntccalculator.html
#
def convertApriliaTempSensorAdcToDegC(adc):
    # Work backwards to get the voltage we must have measured.
    # Vref is nominally 5.0V, and the ADC is 8 bits (255 max value)
    Vref = 5.0
    Vmeas = adc * Vref / 255.0

    # Based on color code, Rtop (R751 or R781) is 2.70K 0.5% (red/violet/black/brown/green).
    # It measures out at 2.70K, so that is accurate.
    Rtop = 2700

    # Work out what the resistance of the thermistor must have been to generate the Voltage we measured
    Rntc = (Vmeas * Rtop) / (Vref - Vmeas)

    # Convert an NTC resistor to a temperature using the Beta method
    #
    # The Beta constant was calculated from the ntccalculator website, above
    # The resistances for the Beta calculation came from measurements of sensor resistances at 0C, 25C, and 90C.
    # I am making an assumption that the NTC resistor in the Aprilia sensor is rated 2K Ohms at 25C.
    # I measured it at 1992 Ohms at 25C. 2K is a standard NTC value, so this seems reasonable.
    R25 = 1992
    Beta = 3526
    degC_Beta = (1/((1/Beta)*math.log(Rntc/R25)+(1/(25+273.15))))-273.15

    # The Steinhart-Hart coefficients come from the same calculator website, as above
    # Resistance/temperature Measurements come from an experiment I ran a long time ago.
    # I will try to find that data and get it republished. In the meantime:
    A = 1.142579776e-3          # 5880 Ohms at 0C
    B = 2.941596847e-4          # 1992 Ohms at 25C
    C = -0.5305974726e-7        #  249 Ohms at 90C
    logR = math.log(Rntc)
    degC_SH = (1/(A + (B * logR) + (C * (logR**3)))) - 273.15
    
    global maxDiff
    diff = abs((degC_Beta - degC_SH))
    if diff > maxDiff:
        maxDiff = diff
    # print(f"beta: {degC_Beta:.1f}, SH: {degC_SH:.1f}")
    
    # Experiments show that S_H and Beta differ by about 1 degree at most, so it probably does not matter which
    # one to use. Nonetheless, the S-H method is known to be more accurate so we use it.
    return degC_SH


def read(f, readCount, showAddress=False, newLine=True):
    global address
    global showBinData

    try:
        bytes = f.read(readCount)
    except:
        exit(0)
    
    if (showBinData):
        if (showAddress):
            print(f"0x{address:08X}: ", end="")

        for byte in bytes:
            print(f"{byte:02X} ", end="")

        if (not showAddress and newLine):
            print("")

    address += readCount
    return bytes

def main():
    global headingsPrinted
    global cr_ts
    global fc_off
    global rc_off
    global aap
    global map
    global vm_V
    global vta
    global skipBytes
    global cr_ts_prev
    global elapsed
    global cridPrev
    global crid
    global epromIdString
    global currentEpromId
    global rpm_avg
    global secs
    global fi_on
    global ri_on
    global fi_dur
    global ri_dur

    # Create argument parser
    parser = argparse.ArgumentParser(description='Decode logs generated by the umod4 system.')
    parser.add_argument('logfile', help='Input log file to decode')
    parser.add_argument('--skip', type=parse_skip_bytes, default=0, help='Number of bytes to skip at start of file (default: 0)')
    parser.add_argument('-L', '--Logsyms', help='Path to directory containing a specific version of the Logsyms package (optional)')

    parser.add_argument('-o', '--output', help='Output file (default: stdout)')
    
    # Parse arguments
    args = parser.parse_args()
    
    # Open output file or use stdout
    if args.output:
        try:
            output_file = open(args.output, 'w')
            old_stdout = sys.stdout
            sys.stdout = output_file
        except Exception as e:
            print(f"Error opening output file: {e}")
            return 1
    else:
        output_file = None
    
    # Add the umod4's venv site-packages to Python path
    from pathlib import Path

    if args.Logsyms:
        # Use the path defined on the cmdline
        site_packages = args.Logsyms
    else:
        # Get the directory containing the current script
        script_dir = Path(__file__).parent.absolute()

        # Get an absolute path to the .venv
        venv_path = os.path.join(script_dir, "..", "..", "build", ".venv")

        # Use that to find where the packages live
        site_packages = os.path.join(venv_path, "lib", f"python{sys.version_info.major}.{sys.version_info.minor}", "site-packages")

    sys.path.insert(0, site_packages)
    print(f"# Logsyms imported from <${site_packages}>")
    
    # Finally: import the package containing all the log symbol definitions
    # Create an alias so that the symbols defined in class Logsyms can be referenced as L.<symname>
    import Logsyms as ls
    L = ls.Logsyms

    try:
        logfilename = args.logfile
        
        skipBytes = args.skip
        
        recordCnt = 0
        
        with open(logfilename, "rb") as f:

            if (skipBytes > 0) :
                print(f"Skipping {skipBytes} at the start of the log")

                while (skipBytes > 0):
                    b = read(f, 1, False);
                    skipBytes -= 1

                print(f"Decoding rest of log:")

            while (True):
                b = read(f, 1, True)
                if (len(b) < 1):
                    break

                recordCnt = recordCnt+1

                byte = b[0]
                # Python does not have a useful equivalent of a C 'switch' statement, so we get a giant if-tree:
                if byte == L.LOGID_GEN_ECU_LOG_VER_TYPE_U8:
                    rd = read(f, L.LOGID_GEN_ECU_LOG_VER_DLEN)
                    print(f"{recordCnt:10}: ECU_VR: {rd[0]}")
                
                elif byte == L.LOGID_GEN_EP_LOG_VER_TYPE_U8:
                    rd = read(f, L.LOGID_GEN_EP_LOG_VER_DLEN)
                    print(f"{recordCnt:10}: EP_VR:  {rd[0]}")
                
                elif byte == L.LOGID_GEN_WP_LOG_VER_TYPE_U8:
                    rd = read(f, L.LOGID_GEN_WP_LOG_VER_DLEN)
                    print(f"{recordCnt:10}: WP_VR:  {rd[0]}")
                
                # Handle ECU events
                elif byte == L.LOGID_ECU_CPU_EVENT_TYPE_U8:
                    event = read(f, L.LOGID_ECU_CPU_EVENT_DLEN)[0]
                    print(f"{recordCnt:10}: CPU:    {event}")

                elif byte == L.LOGID_ECU_L4000_EVENT_TYPE_U8:
                    rd = read(f, L.LOGID_ECU_L4000_EVENT_DLEN)
                    print(f"{recordCnt:10}: L4000:  {rd[0]}")
                
                elif byte == L.LOGID_ECU_F_INJ_ON_TYPE_TS:
                    fi_on = int.from_bytes(read(f, L.LOGID_ECU_F_INJ_ON_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: FI_ON:  {fi_on}")

                elif byte == L.LOGID_ECU_F_INJ_DUR_TYPE_U16:
                    fi_dur = int.from_bytes(read(f, L.LOGID_ECU_F_INJ_DUR_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: FI_DUR: {fi_dur}")

                elif byte == L.LOGID_ECU_R_INJ_ON_TYPE_TS:
                    ri_on = int.from_bytes(read(f, L.LOGID_ECU_R_INJ_ON_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: RI_ON:  {ri_on}")

                elif byte == L.LOGID_ECU_R_INJ_DUR_TYPE_U16:
                    ri_dur = int.from_bytes(read(f, L.LOGID_ECU_R_INJ_DUR_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: RI_DUR: {ri_dur}")

                elif byte == L.LOGID_ECU_F_COIL_ON_TYPE_TS:
                    fc_on = int.from_bytes(read(f, L.LOGID_ECU_F_COIL_ON_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: FC_ON:  {fc_on}")
                
                elif byte == L.LOGID_ECU_F_COIL_OFF_TYPE_TS:
                    fc_off = int.from_bytes(read(f, L.LOGID_ECU_F_COIL_OFF_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: FC_OFF: {fc_off}")
                
                elif byte == L.LOGID_ECU_R_COIL_ON_TYPE_TS:
                    rc_on = int.from_bytes(read(f, L.LOGID_ECU_R_COIL_ON_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: RC_ON:  {rc_on}")

                elif byte == L.LOGID_ECU_R_COIL_OFF_TYPE_TS:
                    rc_off = int.from_bytes(read(f, L.LOGID_ECU_R_COIL_OFF_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: RC_OFF: {rc_off}")

                elif byte == L.LOGID_ECU_F_COIL_MAN_ON_TYPE_TS:
                    fcm_on = int.from_bytes(read(f, L.LOGID_ECU_F_COIL_MAN_ON_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: FC_MON: {fcm_on}")
                
                elif byte == L.LOGID_ECU_F_COIL_MAN_OFF_TYPE_TS:
                    fcm_off = int.from_bytes(read(f, L.LOGID_ECU_F_COIL_MAN_OFF_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: FC_MOF: {fcm_off}")
                
                elif byte == L.LOGID_ECU_R_COIL_MAN_ON_TYPE_TS:
                    rcm_on = int.from_bytes(read(f, L.LOGID_ECU_R_COIL_MAN_ON_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: RC_MON: {rcm_on}")

                elif byte == L.LOGID_ECU_R_COIL_MAN_OFF_TYPE_TS:
                    rcm_off = int.from_bytes(read(f, L.LOGID_ECU_R_COIL_MAN_OFF_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: RC_MOF: {rcm_off}")

                elif byte == L.LOGID_ECU_F_IGN_DLY_TYPE_0P8:
                    b = read(f, L.LOGID_ECU_F_IGN_DLY_DLEN)[0]
                    dly= (b/256)*90.0
                    print(f"{recordCnt:10}: FID:    {dly:.1f}")

                elif byte == L.LOGID_ECU_R_IGN_DLY_TYPE_0P8:
                    b = read(f, L.LOGID_ECU_R_IGN_DLY_DLEN)[0]
                    dly= (b/256)*90.0
                    print(f"{recordCnt:10}: RID:    {dly:.1f}")

                elif byte == L.LOGID_ECU_5MILLISEC_EVENT_TYPE_V:
                    ignore = read(f, L.LOGID_ECU_5MILLISEC_EVENT_DLEN)
                    print(f"{recordCnt:10}: 5MS:")
                    
                elif byte == L.LOGID_ECU_CRANK_P6_MAX_TYPE_V:
                    ignore = read(f, L.LOGID_ECU_CRANK_P6_MAX_DLEN)
                    print(f"{recordCnt:10}: CMX:    Crank Max")

                elif byte == L.LOGID_ECU_FUEL_PUMP_TYPE_B:
                    pumpstate = read(f, L.LOGID_ECU_FUEL_PUMP_DLEN)[0]
                    print(f"{recordCnt:10}: FP:     {pumpstate}")

                elif byte == L.LOGID_ECU_ECU_ERROR_L000C_TYPE_U8:
                    L000C = read(f, L.LOGID_ECU_ECU_ERROR_L000C_DLEN)[0]
                    print(f"{recordCnt:10}: ELC:    " + "{:08b} ".format(L000C), end="")
                    decodeL000C(L000C)

                elif byte == L.LOGID_ECU_ECU_ERROR_L000D_TYPE_U8:
                    L000D = read(f, L.LOGID_ECU_ECU_ERROR_L000D_DLEN)[0]
                    print(f"{recordCnt:10}: ELD:    " + "{:08b} ".format(L000D), end="")
                    decodeL000D(L000D)

                elif byte == L.LOGID_ECU_ECU_ERROR_L000E_TYPE_U8:
                    L000E = read(f, L.LOGID_ECU_ECU_ERROR_L000E_DLEN)[0]
                    print(f"{recordCnt:10}: ELE:    " + "{:08b} ".format(L000E), end="")
                    decodeL000C(L000E)

                elif byte == L.LOGID_ECU_ECU_ERROR_L000F_TYPE_U8:
                    L000F = read(f, L.LOGID_ECU_ECU_ERROR_L000F_DLEN)[0]
                    print(f"{recordCnt:10}: ELF:    " + "{:08b} ".format(L000F), end="")
                    decodeL000D(L000F)

                elif byte == L.LOGID_ECU_RAW_VTA_TYPE_U16:
                    vta = int.from_bytes(read(f, L.LOGID_ECU_RAW_VTA_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: VTA:    {vta}")
                        

                elif byte == L.LOGID_ECU_RAW_MAP_TYPE_U8:
                    map = read(f, 1)[0]
                    print(f"{recordCnt:10}: MAP:    {map}")

                elif byte == L.LOGID_ECU_RAW_AAP_TYPE_U8:
                    aap = read(f, 1)[0]
                    print(f"{recordCnt:10}: AAP:    {aap}")

                elif byte == L.LOGID_ECU_RAW_THW_TYPE_U8:
                    thw_adc = read(f, 1)[0]
                    
                    thw_C = convertApriliaTempSensorAdcToDegC(thw_adc)
                    print(f"{recordCnt:10}: THW:    {thw_C:.1f}C")

                elif byte == L.LOGID_ECU_RAW_THA_TYPE_U8:
                    tha_adc = read(f, 1)[0]
                    
                    tha_C = convertApriliaTempSensorAdcToDegC(tha_adc)
                    print(f"{recordCnt:10}: THA:    {tha_C:.1f}C")

                elif byte == L.LOGID_ECU_RAW_VM_TYPE_U8:
                    # The VM input divides the input voltage by 4 via resistor divider
                    # then feeds it to an ADC where 5V represents the max ADC value 0xFF.
                    adc = read(f, 1)[0]
                    vm_V = (adc/256) * 5 * 4
                    print(f"{recordCnt:10}: VM:     {vm_V:.2f}")

                elif byte == L.LOGID_ECU_PORTG_DB_TYPE_U8:
                    portg = read(f, 1)[0]
                    print(f"{recordCnt:10}: PTG:    " + "{:08b}".format(portg))

                elif byte == L.LOGID_ECU_CRANKREF_START_TYPE_TS:
                    cr_ts = int.from_bytes(read(f, L.LOGID_ECU_CRANKREF_START_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: CRK_TS: {cr_ts}")

                    if (cr_ts_prev > -1):
                        elapsed = cr_ts - cr_ts_prev
                        if (elapsed<0):
                            elapsed += 65536
                    
                    cr_ts_prev = cr_ts
                    if (elapsed >= 0):
                        rpm = 60000000 / (elapsed * 2 * 6)

                        rpm_hist.append(rpm)
                        if (len(rpm_hist) == 7):
                            rpm_hist.pop(0)
                        rpm_avg = sum(rpm_hist) / len(rpm_hist)

                        print(f"{recordCnt:10}: cr_ts: {cr_ts}, elapsed: {elapsed}, RPM-INST {rpm:.0f}, RPM-AVG {rpm_avg:.0f}")

                elif byte == L.LOGID_ECU_CRANKREF_ID_TYPE_U8:
                    crid = read(f, 1)[0]
                    print(f"{recordCnt:10}: CR:  {crid}")
                    if (elapsed > 0):
                        if not headingsPrinted:
                            headingsPrinted = True
                            print(f"XL, secs, crid, cr_ts, elapsed, tha_C, thw_C, vm_V, map, aap, vta, rpm_avg, fi_dur, ri_dur, fc_off, rc_off")
                        
                        fco = rco = 0
                        if crid == 5:
                            fco = fc_off
                        elif crid == 10:
                            rco = rc_off
                        print(f"XL, {secs:2}, {crid:2}, {cr_ts:5}, {elapsed:5}, {tha_C:.1f}, {thw_C:.1f}, {vm_V:.1f}, {map}, {aap}, {vta:3}, {rpm_avg:5.0f}, {fi_dur}, {ri_dur}, {fco}, {rco}")
                        if (fi_dur != 0):
                            fi_dur = 0
                        if (ri_dur != 0):
                            ri_dur = 0

                    if (cridPrev >= 0):
                        expectedId = cridPrev+1
                        if (expectedId>11):
                            expectedId = 0
                        if (crid != expectedId):
                            print(f"{recordCnt:10}: ERROR: expected CRID {expectedId}, saw {crid}")

                elif byte == L.LOGID_ECU_CAMSHAFT_TYPE_TS:
                    cam_ts = int.from_bytes(read(f, L.LOGID_ECU_CAMSHAFT_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: CAM_TS:  {cam_ts}")

                elif byte == L.LOGID_ECU_CAM_ERR_TYPE_U8:
                    camErr = read(f, 1)[0]
                    print(f"{recordCnt:10}: CAM ERR: {camErr:02X}")

                elif byte == L.LOGID_ECU_SPRK_X1_TYPE_TS:
                    spx1_ts = int.from_bytes(read(f, L.LOGID_ECU_SPRK_X1_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: SP1_TS: {spx1_ts}")

                elif byte == L.LOGID_ECU_SPRK_X2_TYPE_TS:
                    spx2_ts = int.from_bytes(read(f, L.LOGID_ECU_SPRK_X2_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: SP2_TS: {spx2_ts}")

                elif byte == L.LOGID_ECU_NOSPARK_TYPE_U8:
                    sparkErr = read(f, 1)[0]
                    print(f"{recordCnt:10}: NOSPRK: {sparkErr:02X}")

                # EP-specific events
                elif byte == L.LOGID_GEN_EP_LOG_VER_TYPE_U8:
                    rd = read(f, 1)
                    print(f"{recordCnt:10}: EPV:    {rd[0]}")

                elif byte == L.LOGID_EP_LOAD_NAME_TYPE_U8:
                    # Each write to this address appends the next byte as a char to the EPROM_ID_STR
                    c = read(f, 1)[0]
                    if (c != 0):
                        epromIdString = "".join([epromIdString, chr(c)])
                    else:
                        currentEpromId = epromIdString
                        epromIdString = ""
                        print(f"{recordCnt:10}: LOAD:   {currentEpromId}")

                elif byte == L.LOGID_EP_LOAD_ADDR_TYPE_U16:
                    epromStartAddr = int.from_bytes(read(f, L.LOGID_EP_LOAD_ADDR_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: ADDR:   0x{epromStartAddr:04X}")

                elif byte == L.LOGID_EP_LOAD_LEN_TYPE_U16:
                    epromLen = int.from_bytes(read(f, L.LOGID_EP_LOAD_LEN_DLEN), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: LEN:    0x{epromLen:04X}")

                elif byte == L.LOGID_EP_LOAD_ERR_TYPE_U8:
                    loadErr = read(f, L.LOGID_EP_LOAD_ERR_DLEN)[0]
                    if loadErr == L.LOGID_EP_LOAD_ERR_VAL_NOERR:
                        print(f"{recordCnt:10}: STAT: ERR_NOERR")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_NOTFOUND:
                        print(f"{recordCnt:10}: STAT: ERR_NOTFOUND")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_NONAME:
                        print(f"{recordCnt:10}: STAT: ERR_NONAME")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_CKSUMERR:
                        print(f"{recordCnt:10}: STAT: ERR_CKSUMERR")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_VERIFYERR:
                        print(f"{recordCnt:10}: STAT: ERR_VERIFYERR")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_BADOFFSET:
                        print(f"{recordCnt:10}: STAT: ERR_BADOFFSET")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_BADLENGTH:
                        print(f"{recordCnt:10}: STAT: ERR_BADLENGTH")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_NODAUGHTERBOARDKEY:
                        print(f"{recordCnt:10}: STAT: ERR_NODAUGHTERBOARDKEY")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_NOMEMKEY:
                        print(f"{recordCnt:10}: STAT: ERR_NOMEMKEY")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_M3FAIL:
                        print(f"{recordCnt:10}: STAT: ERR_M3FAIL")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_MISSINGKEYSTART:
                        print(f"{recordCnt:10}: STAT: ERR_MISSING_KEY_START")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_MISSINGKEYLENGTH:
                        print(f"{recordCnt:10}: STAT: ERR_MISSING_KEY_LENGTH")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_MISSINGKEYM3:
                        print(f"{recordCnt:10}: STAT: ERR_KEY_M3")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_BADM3BSONTYPE:
                        print(f"{recordCnt:10}: STAT: ERR_BAD_M3_BSON_TYPE")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_BADM3VALUE:
                        print(f"{recordCnt:10}: STAT: ERR_BAD_M3_VALUE")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_NOBINKEY:
                        print(f"{recordCnt:10}: STAT: ERR_NOBINKEY")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_BADBINLENGTH:
                        print(f"{recordCnt:10}: STAT: ERR_BADBINLENGTH")
                    elif loadErr == L.LOGID_EP_LOAD_ERR_VAL_BADBINSUBTYPE:
                        print(f"{recordCnt:10}: STAT: ERR_BADBINSUBTYPE")
                    else:
                        print(f"{recordCnt:10}: STAT: Unknown error: 0x{loadErr:02X}")

                # WP-specific events
                elif byte == L.LOGID_GEN_WP_LOG_VER_TYPE_U8:
                    rd = read(f, L.LOGID_GEN_WP_LOG_VER_DLEN)
                    print(f"{recordCnt:10}: WPV:    {rd[0]}")

                elif byte == L.LOGID_WP_CSECS_TYPE_U8:
                    csecs = read(f, L.LOGID_WP_CSECS_DLEN)[0]
                    print(f"{recordCnt:10}: CS:     {csecs:02}")

                elif byte == L.LOGID_WP_SECS_TYPE_U8:
                    secs = read(f, L.LOGID_WP_SECS_DLEN)[0]
                    print(f"{recordCnt:10}: SEC:    {secs:02}")

                elif byte == L.LOGID_WP_MINS_TYPE_U8:
                    mins = read(f, L.LOGID_WP_MINS_DLEN)[0]
                    print(f"{recordCnt:10}: MIN:    {mins:02}")

                elif byte == L.LOGID_WP_HOURS_TYPE_U8:
                    hours = read(f, L.LOGID_WP_HOURS_DLEN)[0]
                    print(f"{recordCnt:10}: HRS:    {hours:02}")

                elif byte == L.LOGID_WP_DATE_TYPE_U8:
                    date = read(f, L.LOGID_WP_DATE_DLEN)[0]
                    print(f"{recordCnt:10}: DT:     {date:02}")

                elif byte == L.LOGID_WP_MONTH_TYPE_U8:
                    month = read(f, L.LOGID_WP_MONTH_DLEN)[0]
                    print(f"{recordCnt:10}: MON:    {month:02}")

                elif byte == L.LOGID_WP_YEAR_TYPE_U8:
                    year = read(f, L.LOGID_WP_YEAR_DLEN)[0]
                    print(f"{recordCnt:10}: YR:     {year:02}")

                elif byte == L.LOGID_WP_FIXTYPE_TYPE_U8:
                    fix = read(f, L.LOGID_WP_FIXTYPE_DLEN)[0]
                    print(f"{recordCnt:10}: FIX:    {fix}")

                elif byte == L.LOGID_WP_GPS_POSN_TYPE_8B:
                    # Position & Velocity data: 2 args in the 8 bytes that follow
                    argLen = L.LOGID_WP_GPS_POSN_DLEN / 2
                    lat =  int.from_bytes(read(f, argLen, newLine=False), byteorder='little', signed=True) / 10000000.0
                    long = int.from_bytes(read(f, argLen, newLine=False), byteorder='little', signed=True) / 10000000.0
                    print(f"{recordCnt:10}: GPS_POSN: {lat:.8f} {long:.8f}")

                elif byte == L.LOGID_WP_GPS_VELO_TYPE_U16:
                    # Velocity is encoded in a uint16_t as (velocity*10) MPH
                    vel =  int.from_bytes(read(f, L.LOGID_WP_GPS_VELO_DLEN), byteorder='little', signed=True) / 10.0
                    print(f"{recordCnt:10}: GPS_VEL: {vel:.1f}")

                elif byte == L.LOGID_WP_WR_TIME_TYPE_U16:
                    # Time follows as 2 bytes, LSB first
                    wrTime = int.from_bytes(read(f, 2), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: WRT:    {wrTime} msec")

                elif byte == L.LOGID_WP_SYNC_TIME_TYPE_U16:
                    # Log filesystem sync() time follows as 2 bytes, LSB first
                    syncTime = int.from_bytes(read(f, 2), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: SYT:    {syncTime} msec")

                else:
                    print(f"{recordCnt:10}: ERR:    Unknown LOGID 0x{byte:02X}")
                    #read(f, 1)

    except FileNotFoundError:
        print(f"Error: File '{args.logfile}' not found.")
        return 1
    except Exception as e:
        print(f"Error processing file: {e}")
        return 1
    finally:
        # Restore stdout if we redirected it
        if output_file:
            sys.stdout = old_stdout
            output_file.close()

        # print(f"Max difference between Beta and S-H calculations: {maxDiff:.1f}C")

if __name__ == "__main__":
    sys.exit(main())
