#!/usr/bin/env python3

# Decode logs generated by the umod4 system.
#
# To do this 'manually' to decode a log file, invoke this script as follows:
#
#    <path-to-decodelog.py> <binary-log-file-to-decode>
#
# example:
#    ~/projects/umod4/tools/src/decodelog.py ~/logs/log.17
#

import sys
import os
import math
import argparse

# Add the umod4's venv site-packages to Python path
from pathlib import Path

# Get the directory containing the current script
script_dir = Path(__file__).parent.absolute()

# Get an absolute path to the .venv
venv_path = os.path.join(script_dir, "..", "..", "build", ".venv")

# Use that to find where the packages live
site_packages = os.path.join(venv_path, "lib", f"python{sys.version_info.major}.{sys.version_info.minor}", "site-packages")
print(f"Site-packages: <{site_packages}>")

sys.path.insert(0, site_packages)

# Finally: import the package containing all the log symbol definitions
# The symbols defined in the Logsyms class will be referenced in this file as ls.Logsyms.<symname>
import Logsyms as ls



headingsPrinted = False
msb = 0
msb_id = -1

# Number of bytes to skip at the start before decoding the rest of the file
skipBytes = 0

def parse_skip_bytes(value):
    try:
        return int(value)
    except ValueError:
        raise argparse.ArgumentTypeError(f"skipBytes must be an integer, got '{value}'")

tNow = 0
fc_off = 0
rc_off = 0
map = -1
aap = -1
vm_V = -1
vta = -1
vtaPrev = -1
tPrev = -1
elapsed = -1
cridPrev = -1
crid = -1
epromIdString = ""
currentEpromId = epromIdString
rpm_avg = 0.0
secs=-1

fi_on = -1
ri_on = -1
ri_dur = 0
fi_dur = 0

showBinData = True
address = 0

# Track the max difference between the two methods of converting thermistor readings to temperatures
maxDiff = 0.0

import array as arr
rpm_hist = arr.array('d', [])

f=""
stashed_id = -1
stashed_data = -1

def stash(id, data):
    global stashed_id
    global stashed_data
    
    if (stashed_id >= 0):
        print(f"ERR: attempt to stash msb for ID ${id} when ID ${msb_id} has something stashed already")
        return -1
    
    stashed_id = id
    stashed_data = data
    return 0

def retrieve(expectedId):
    global stashed_id
    global stashed_data

    if (stashed_id != expectedId):
        print(f"ERR: expecting that ID {expectedId:02X} had been stashed, saw {stashed_id:02X}")
        stashed_id = -1
        return -1
    
    stashed_id = -1
    return stashed_data


def decodeL000C(byte):
    if (byte & 0x80):
        print(f"Bad CAM,", end="")
    if (byte & 0x40):
        print(f"Bad CRANK,", end="")
    if (byte & 0x20):
        print(f"Bad MAP,", end="")
    if (byte & 0x10):
        print(f"Bad AN2,", end="")
    if (byte & 0x08):
        print(f"Bad VTA,", end="")
    if (byte & 0x04):
        print(f"Bad THW,", end="")
    if (byte & 0x02):
        print(f"Bad THA,", end="")
    if (byte & 0x01):
        print(f"Bad AAP", end="")
    print()

# Decoding L000D and L000F are identical. 
# L000D events can get "better" if the sensor comes back on-line,
# but L000F events are "sticky" until the ECU powers down again.
def decodeL000D(byte):
    if (byte & 0x80):
        print(f"?B7,", end="")
    if (byte & 0x40):
        print(f"?B6,", end="")
    if (byte & 0x20):
        print(f"?B5,", end="")
    if (byte & 0x10):
        print(f"Bad Rcoil1,", end="")
    if (byte & 0x08):
        print(f"Bad Rcoil2,", end="")
    if (byte & 0x04):
        print(f"Bad Fcoil1,", end="")
    if (byte & 0x02):
        print(f"Bad Fcoil2,", end="")
    if (byte & 0x01):
        print(f"Bad DON", end="")
    print()

# This function converts a raw 8-bit ADC reading of an Aprilia temperature sensor back to degrees C.
#
# An excellent calculator of NTC thermistor response can be found here:
#   https://www.thinksrs.com/downloads/programs/therm%20calc/ntccalibrator/ntccalculator.html
#
def convertApriliaTempSensorAdcToDegC(adc):
    # Work backwards to get the voltage we must have measured.
    # Vref is nominally 5.0V, and the ADC is 8 bits (255 max value)
    Vref = 5.0
    Vmeas = adc * Vref / 255.0

    # Based on color code, Rtop (R751 or R781) is 2.70K 0.5% (red/violet/black/brown/green).
    # It measures out at 2.70K, so that is accurate.
    Rtop = 2700

    # Work out what the resistance of the thermistor must have been to generate the Voltage we measured
    Rntc = (Vmeas * Rtop) / (Vref - Vmeas)

    # Convert an NTC resistor to a temperature using the Beta method
    #
    # The Beta constant was calculated from the ntccalculator website, above
    # The resistances for the Beta calculation came from measurements of sensor resistances at 0C, 25C, and 90C.
    # I am making an assumption that the NTC resistor in the Aprilia sensor is rated 2K Ohms at 25C.
    # I measured it at 1992 Ohms at 25C. 2K is a standard NTC value, so this seems reasonable.
    R25 = 1992
    Beta = 3526
    degC_Beta = (1/((1/Beta)*math.log(Rntc/R25)+(1/(25+273.15))))-273.15

    # The Steinhart-Hart coefficients come from the same calculator website, as above
    # Resistance/temperature Measurements come from an experiment I ran a long time ago.
    # I will try to find that data and get it republished. In the meantime:
    A = 1.142579776e-3          # 5880 Ohms at 0C
    B = 2.941596847e-4          # 1992 Ohms at 25C
    C = -0.5305974726e-7        #  249 Ohms at 90C
    logR = math.log(Rntc)
    degC_SH = (1/(A + (B * logR) + (C * (logR**3)))) - 273.15
    
    global maxDiff
    diff = abs((degC_Beta - degC_SH))
    if diff > maxDiff:
        maxDiff = diff
    # print(f"beta: {degC_Beta:.1f}, SH: {degC_SH:.1f}")
    
    # Experiments show that S_H and Beta differ by about 1 degree at most, so it probably does not matter which
    # one to use. Nonetheless, the S-H method is known to be more accurate so we use it.
    return degC_SH


def read(f, readCount, showAddress=False, newLine=True):
    global address
    global showBinData

    try:
        bytes = f.read(readCount)
    except:
        exit(0)
    
    if (showBinData):
        if (showAddress):
            print(f"0x{address:08X}: ", end="")

        for byte in bytes:
            print(f"{byte:02X} ", end="")

        if (not showAddress and newLine):
            print("")

    address += readCount
    return bytes

def main():
    global headingsPrinted
    global tNow
    global fc_off
    global rc_off
    global aap
    global map
    global vm_V
    global vta
    global skipBytes
    global tPrev
    global elapsed
    global cridPrev
    global crid
    global epromIdString
    global currentEpromId
    global rpm_avg
    global secs
    global fi_on
    global ri_on
    global fi_dur
    global ri_dur

    # Create argument parser
    parser = argparse.ArgumentParser(description='Decode logs generated by the umod4 system.')
    parser.add_argument('logfile', help='Input log file to decode')
    parser.add_argument('--skip', type=parse_skip_bytes, default=0, help='Number of bytes to skip at start of file (default: 0)')
    parser.add_argument('-o', '--output', help='Output file (default: stdout)')
    
    # Parse arguments
    args = parser.parse_args()
    
    # Open output file or use stdout
    if args.output:
        try:
            output_file = open(args.output, 'w')
            old_stdout = sys.stdout
            sys.stdout = output_file
        except Exception as e:
            print(f"Error opening output file: {e}")
            return 1
    else:
        output_file = None
    
    try:
        logfilename = args.logfile
        
        skipBytes = args.skip
        
        recordCnt = 0
        
        with open(logfilename, "rb") as f:

            if (skipBytes > 0) :
                print(f"Skipping {skipBytes} at the start of the log")

                while (skipBytes > 0):
                    b = read(f, 1, False);
                    skipBytes -= 1

                print(f"Decoding rest of log:")

            while (True):
                b = read(f, 1, True)
                if (len(b) < 1):
                    break

                recordCnt = recordCnt+1

                byte = b[0]
                # Python does not have a useful equivalent of a C 'switch' statement, so we get a giant if-tree:
                if byte == ls.Logsyms.LOGID_ECU_LOG_VER_U8:
                    rd = read(f, 1)
                    print(f"{recordCnt:10}: ECU_VR: {rd[0]}")
                
                elif byte == ls.Logsyms.LOGID_EP_LOG_VER_U8:
                    rd = read(f, 1)
                    print(f"{recordCnt:10}: EP_VR:  {rd[0]}")
                
                elif byte == ls.Logsyms.LOGID_WP_LOG_VER_U8:
                    rd = read(f, 1)
                    print(f"{recordCnt:10}: WP_VR:  {rd[0]}")
                
                # Handle ECU events
                elif byte == ls.Logsyms.LOGID_ECU_CPU_EVENT_U8:
                    event = read(f, 1)[0]
                    print(f"{recordCnt:10}: CPU:    {event}")

                elif byte == ls.Logsyms.LOGID_ECU_L4000_EVENT_U8:
                    rd = read(f, 1)
                    print(f"{recordCnt:10}: L4000:  {rd[0]}")
                
                elif byte == ls.Logsyms.LOGID_ECU_F_INJ_ON_TS_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_F_INJ_ON_TS_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_F_INJ_ON_TS_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_F_INJ_ON_TS_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        fi_on = data16
                        print(f"{recordCnt:10}: FI_ON:  {data16}")

                elif byte == ls.Logsyms.LOGID_ECU_F_INJ_DUR_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_F_INJ_DUR_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_F_INJ_DUR_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_F_INJ_DUR_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        fi_dur = data16
                        print(f"{recordCnt:10}: FI_DUR: {fi_dur}")

                elif byte == ls.Logsyms.LOGID_ECU_R_INJ_ON_TS_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_R_INJ_ON_TS_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_R_INJ_ON_TS_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_R_INJ_ON_TS_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        ri_on = data16
                        print(f"{recordCnt:10}: RI_ON:  {data16}")

                elif byte == ls.Logsyms.LOGID_ECU_R_INJ_DUR_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_R_INJ_DUR_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_R_INJ_DUR_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_R_INJ_DUR_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        ri_dur = data16
                        print(f"{recordCnt:10}: RI_DUR: {ri_dur}")

                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_ON_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_ON_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_ON_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_ON_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        print(f"{recordCnt:10}: FC_ON:  {data16}")
                
                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_OFF_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_OFF_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_OFF_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_OFF_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        fc_off = data16
                        print(f"{recordCnt:10}: FC_OFF: {fc_off}")
                
                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_ON_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_ON_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_ON_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_ON_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        print(f"{recordCnt:10}: RC_ON:  {data16}")

                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_OFF_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_OFF_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_OFF_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_OFF_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        rc_off = data16
                        print(f"{recordCnt:10}: RC_OFF: {rc_off}")

                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_ON_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_ON_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_ON_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_ON_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        print(f"{recordCnt:10}: FC_MON: {data16}")
                
                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_OFF_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_OFF_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_OFF_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_FRT_COIL_MAN_OFF_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        print(f"{recordCnt:10}: FC_MOF: {data16}")
                
                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_ON_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_ON_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_ON_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_ON_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        print(f"{recordCnt:10}: RC_MON: {data16}")

                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_OFF_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_OFF_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_OFF_U16+1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_REAR_COIL_MAN_OFF_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        print(f"{recordCnt:10}: RC_MOF: {data16}")

                elif byte == ls.Logsyms.LOGID_ECU_TS_FRT_IGN_DLY_0P8:
                    b = read(f, 1)[0]
                    dly= (b/256)*90.0
                    print(f"{recordCnt:10}: FID:    {dly:.1f}")

                elif byte == ls.Logsyms.LOGID_ECU_TS_REAR_IGN_DLY_0P8:
                    b = read(f, 1)[0]
                    dly= (b/256)*90.0
                    print(f"{recordCnt:10}: RID:    {dly:.1f}")

                elif byte == ls.Logsyms.LOGID_ECU_5MILLISEC_EVENT_V:
                    ignore = read(f, 1)
                    print(f"{recordCnt:10}: 5MS:")
                    
                elif byte == ls.Logsyms.LOGID_ECU_CRANK_P6_MAX_V:
                    ignore = read(f, 1)
                    print(f"{recordCnt:10}: CMX:    Crank Max")

                elif byte == ls.Logsyms.LOGID_ECU_FUEL_PUMP_B:
                    pumpstate = read(f, 1)[0]
                    print(f"{recordCnt:10}: FP:     {pumpstate}")

                elif byte == ls.Logsyms.LOGID_ECU_ECU_ERROR_L000C_U8:
                    L000C = read(f, 1)[0]
                    print(f"{recordCnt:10}: ELC:    " + "{:08b} ".format(L000C), end="")
                    decodeL000C(L000C)

                elif byte == ls.Logsyms.LOGID_ECU_ECU_ERROR_L000D_U8:
                    L000D = read(f, 1)[0]
                    print(f"{recordCnt:10}: ELD:    " + "{:08b} ".format(L000D), end="")
                    decodeL000D(L000D)

                elif byte == ls.Logsyms.LOGID_ECU_ECU_ERROR_L000E_U8:
                    L000E = read(f, 1)[0]
                    print(f"{recordCnt:10}: ELE:    " + "{:08b} ".format(L000E), end="")
                    decodeL000C(L000E)

                elif byte == ls.Logsyms.LOGID_ECU_ECU_ERROR_L000F_U8:
                    L000F = read(f, 1)[0]
                    print(f"{recordCnt:10}: ELF:    " + "{:08b} ".format(L000F), end="")
                    decodeL000D(L000F)

                elif byte == ls.Logsyms.LOGID_ECU_RAW_VTA_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_RAW_VTA_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_RAW_VTA_U16 + 1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_RAW_VTA_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        vta = data16
                        print(f"{recordCnt:10}: VTA:    {data16}")
                        

                elif byte == ls.Logsyms.LOGID_ECU_RAW_MAP_U8:
                    map = read(f, 1)[0]
                    print(f"{recordCnt:10}: MAP:    {map}")

                elif byte == ls.Logsyms.LOGID_ECU_RAW_AAP_U8:
                    aap = read(f, 1)[0]
                    print(f"{recordCnt:10}: AAP:    {aap}")

                elif byte == ls.Logsyms.LOGID_ECU_RAW_THW_U8:
                    thw_adc = read(f, 1)[0]
                    
                    thw_C = convertApriliaTempSensorAdcToDegC(thw_adc)
                    print(f"{recordCnt:10}: THW:    {thw_C:.1f}C")

                elif byte == ls.Logsyms.LOGID_ECU_RAW_THA_U8:
                    tha_adc = read(f, 1)[0]
                    
                    tha_C = convertApriliaTempSensorAdcToDegC(tha_adc)
                    print(f"{recordCnt:10}: THA:    {tha_C:.1f}C")

                elif byte == ls.Logsyms.LOGID_ECU_RAW_VM_U8:
                    # The VM input divides the input voltage by 4 via resistor divider
                    # then feeds it to an ADC where 5V represents the max ADC value 0xFF.
                    adc = read(f, 1)[0]
                    vm_V = (adc/256) * 5 * 4
                    print(f"{recordCnt:10}: VM:     {vm_V:.2f}")

                elif byte == ls.Logsyms.LOGID_ECU_PORTG_DB_U8:
                    portg = read(f, 1)[0]
                    print(f"{recordCnt:10}: PTG:    " + "{:08b}".format(portg))

                elif byte == ls.Logsyms.LOGID_ECU_TS_CRANKREF_START_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_TS_CRANKREF_START_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_TS_CRANKREF_START_U16 + 1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_TS_CRANKREF_START_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        tNow = data16
                        print(f"{recordCnt:10}: CRK_TS: {tNow}")

                        if (tPrev > -1):
                            elapsed = tNow - tPrev
                            if (elapsed<0):
                                elapsed += 65536
                        
                        tPrev = tNow
                        if (elapsed >= 0):
                            rpm = 60000000 / (elapsed * 2 * 6)

                            rpm_hist.append(rpm)
                            if (len(rpm_hist) == 7):
                                rpm_hist.pop(0)
                            rpm_avg = sum(rpm_hist) / len(rpm_hist)

                            print(f"{recordCnt:10}: tNow: {tNow}, elapsed: {elapsed}, RPM-INST {rpm:.0f}, RPM-AVG {rpm_avg:.0f}")

                elif byte == ls.Logsyms.LOGID_ECU_CRANKREF_ID_U8:
                    crid = read(f, 1)[0]
                    print(f"{recordCnt:10}: CR:  {crid}")
                    if (elapsed > 0):
                        if not headingsPrinted:
                            headingsPrinted = True
                            print(f"XL, secs, crid, tNow, elapsed, tha_C, thw_C, vm_V, map, aap, vta, rpm_avg, fi_dur, ri_dur, fc_off, rc_off")
                        
                        fco = rco = 0
                        if crid == 5:
                            fco = fc_off
                        elif crid == 10:
                            rco = rc_off
                        print(f"XL, {secs:2}, {crid:2}, {tNow:5}, {elapsed:5}, {tha_C:.1f}, {thw_C:.1f}, {vm_V:.1f}, {map}, {aap}, {vta:3}, {rpm_avg:5.0f}, {fi_dur}, {ri_dur}, {fco}, {rco}")
                        if (fi_dur != 0):
                            fi_dur = 0
                        if (ri_dur != 0):
                            ri_dur = 0

                    if (cridPrev >= 0):
                        expectedId = cridPrev+1
                        if (expectedId>11):
                            expectedId = 0
                        if (crid != expectedId):
                            print(f"{recordCnt:10}: ERROR: expected CRID {expectedId}, saw {crid}")

                elif byte == ls.Logsyms.LOGID_ECU_CAMSHAFT_U16:
                    msb = read(f, 1)[0]
                    stash(ls.Logsyms.LOGID_ECU_CAMSHAFT_U16, msb)

                elif byte == ls.Logsyms.LOGID_ECU_CAMSHAFT_U16 + 1:
                    msb = retrieve(ls.Logsyms.LOGID_ECU_CAMSHAFT_U16)
                    if (msb >= 0):
                        lsb = read(f, 1)[0]
                        data16 = (msb*256) + lsb
                        print(f"{recordCnt:10}: CAM_TS:  {data16}")

                elif byte == ls.Logsyms.LOGID_ECU_CAM_ERR_U8:
                    camErr = read(f, 1)[0]
                    print(f"{recordCnt:10}: CAM ERR: {camErr:02X}")

                # EP-specific events
                elif byte == ls.Logsyms.LOGID_EP_LOG_VER_U8:
                    rd = read(f, 1)
                    print(f"{recordCnt:10}: EPV:    {rd[0]}")

                elif byte == ls.Logsyms.LOGID_EP_LOAD_NAME:
                    # Each write to this address appends the next byte as a char to the EPROM_ID_STR
                    c = read(f, 1)[0]
                    if (c != 0):
                        epromIdString = "".join([epromIdString, chr(c)])
                    else:
                        currentEpromId = epromIdString
                        epromIdString = ""
                        print(f"{recordCnt:10}: LOAD:   {currentEpromId}")

                elif byte == ls.Logsyms.LOGID_EP_LOAD_ADDR:
                    # This might need fixing. It takes advantage of the fact that the ECU is not running (for sure),
                    # and that the GPS is probably not running either. 
                    # It should probably convert to logging low and hi to different addresses.
                    # The name needs data typing added too
                    rd = read(f, 3)
                    hi=rd[0]
                    lo=rd[2]
                    epromStartaddr = (hi*256) + lo
                    print(f"{recordCnt:10}: ADDR:   0x{epromStartaddr:04X}")

                elif byte == ls.Logsyms.LOGID_EP_LOAD_LEN:
                    # Also potentially broken, as above
                    rd = read(f, 3)
                    hi=rd[0]
                    lo=rd[2]
                    epromLen = (hi*256) + lo
                    print(f"{recordCnt:10}: LEN:  0x{epromLen:04X}")

                elif byte == ls.Logsyms.LOGID_EP_LOAD_ERR_U8:
                    loadErr = read(f, 1)[0]
                    if loadErr == 0x00:
                        print(f"{recordCnt:10}: STAT: ERR_NOERR")
                    elif loadErr == 0x01:
                        print(f"{recordCnt:10}: STAT: ERR_NOTFOUND")
                    elif loadErr == 0x02:
                        print(f"{recordCnt:10}: STAT: ERR_NONAME")
                    elif loadErr == 0x03:
                        print(f"{recordCnt:10}: STAT: ERR_CKSUMERR")
                    elif loadErr == 0x04:
                        print(f"{recordCnt:10}: STAT: ERR_VERIFYERR")
                    elif loadErr == 0x05:
                        print(f"{recordCnt:10}: STAT: ERR_BADOFFSET")
                    elif loadErr == 0x06:
                        print(f"{recordCnt:10}: STAT: ERR_BADLENGTH")
                    elif loadErr == 0x07:
                        print(f"{recordCnt:10}: STAT: ERR_NODAUGHTERBOARDKEY")
                    elif loadErr == 0x08:
                        print(f"{recordCnt:10}: STAT: ERR_NOMEMKEY")
                    elif loadErr == 0x09:
                        print(f"{recordCnt:10}: STAT: ERR_BADMEMINFO")
                    elif loadErr == 0x0A:
                        print(f"{recordCnt:10}: STAT: ERR_M3FAIL")
                    elif loadErr == 0x0B:
                        print(f"{recordCnt:10}: STAT: ERR_MISSING_KEY_START")
                    elif loadErr == 0x0C:
                        print(f"{recordCnt:10}: STAT: ERR_MISSING_KEY_LENGTH")
                    elif loadErr == 0x0D:
                        print(f"{recordCnt:10}: STAT: ERR_KEY_M3")
                    elif loadErr == 0x0E:
                        print(f"{recordCnt:10}: STAT: ERR_BAD_M3_BSON_TYPE")
                    elif loadErr == 0x0F:
                        print(f"{recordCnt:10}: STAT: ERR_BAD_M3_VALUE")
                    elif loadErr == 0x10:
                        print(f"{recordCnt:10}: STAT: ERR_NOBINKEY")
                    elif loadErr == 0x11:
                        print(f"{recordCnt:10}: STAT: ERR_BADBINLENGTH")
                    elif loadErr == 0x12:
                        print(f"{recordCnt:10}: STAT: ERR_BADBINSUBTYPE")
                    else:
                        print(f"{recordCnt:10}: STAT: Unknown error: 0x{loadErr:02X}")

                # WP-specific events
                elif byte == ls.Logsyms.LOGID_WP_LOG_VER_U8:
                    rd = read(f, 1)
                    print(f"{recordCnt:10}: WPV:    {rd[0]}")

                elif byte == ls.Logsyms.LOGID_WP_CSECS_U8:
                    csecs = read(f, 1)[0]
                    print(f"{recordCnt:10}: CS:     {csecs:02}")

                elif byte == ls.Logsyms.LOGID_WP_SECS_U8:
                    secs = read(f, 1)[0]
                    print(f"{recordCnt:10}: SEC:    {secs:02}")

                elif byte == ls.Logsyms.LOGID_WP_MINS_U8:
                    mins = read(f, 1)[0]
                    print(f"{recordCnt:10}: MIN:    {mins:02}")

                elif byte == ls.Logsyms.LOGID_WP_HOURS_U8:
                    hours = read(f, 1)[0]
                    print(f"{recordCnt:10}: HRS:    {hours:02}")

                elif byte == ls.Logsyms.LOGID_WP_DATE_U8:
                    # LOG_DATE
                    date = read(f, 1)[0]
                    print(f"{recordCnt:10}: DT:     {date:02}")

                elif byte == ls.Logsyms.LOGID_WP_MONTH_U8:
                    month = read(f, 1)[0]
                    print(f"{recordCnt:10}: MON:    {month:02}")

                elif byte == ls.Logsyms.LOGID_WP_YEAR_U8:
                    year = read(f, 1)[0]
                    print(f"{recordCnt:10}: YR:     {year:02}")

                elif byte == ls.Logsyms.LOGID_WP_FIXTYPE_U8:
                    fix = read(f, 1)[0]
                    print(f"{recordCnt:10}: FIX:    {fix}")

                elif byte == ls.Logsyms.LOGID_WP_PV:
                    # Position & Velocity data: 3 args in the 10 bytes that follow
                    lat =  int.from_bytes(read(f, 4, newLine=False), byteorder='little', signed=True) / 10000000.0
                    long = int.from_bytes(read(f, 4, newLine=False), byteorder='little', signed=True) / 10000000.0
                    vel =  int.from_bytes(read(f, 2), byteorder='little', signed=True) / 10.0
                    print(f"{recordCnt:10}: GPS:    {lat:.8f} {long:.8f} {vel:.1f}")

                elif byte == ls.Logsyms.LOGID_WP_WR_TIME:
                    # Time follows as 2 bytes, LSB first
                    wrTime = int.from_bytes(read(f, 2), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: WRT:    {wrTime} msec")

                elif byte == ls.Logsyms.LOGID_WP_SYNC_TIME:
                    # Log filesystem sync() time follows as 2 bytes, LSB first
                    syncTime = int.from_bytes(read(f, 2), byteorder='little', signed=False)
                    print(f"{recordCnt:10}: SYT:    {syncTime} msec")

                else:
                    print(f"{recordCnt:10}: ERR:    Unknown LOGID 0x{byte:02X}")
                    #read(f, 1)

    except FileNotFoundError:
        print(f"Error: File '{args.logfile}' not found.")
        return 1
    except Exception as e:
        print(f"Error processing file: {e}")
        return 1
    finally:
        # Restore stdout if we redirected it
        if output_file:
            sys.stdout = old_stdout
            output_file.close()

        # print(f"Max difference between Beta and S-H calculations: {maxDiff:.1f}C")

if __name__ == "__main__":
    sys.exit(main())
