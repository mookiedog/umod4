/**
 * UF2 Test File for Raspberry Pi Pico
 *
 * This file contains a test UF2 image with the following characteristics:
 * - 16KB of data (all 0xFF)
 * - Targets RP2040 flash at 15MB offset (0x10F00000)
 * - 4 blocks of 4KB each (16 UF2 blocks per 4KB page)
 * - Block layout:
 *   Block 0-15:  Target 0x10F00000-0x10F00FFF (4KB contiguous)
 *   Block 16-31: Target 0x10F01000-0x10F01FFF (4KB contiguous with block 0-15)
 *   Block 32-47: Target 0x10F03000-0x10F03FFF (4KB gap after block 16-31)
 *   Block 48-63: Target 0x10F06000-0x10F06FFF (8KB gap after block 32-47)
 *
 * UF2 Block Structure (512 bytes):
 *   Offset 0x00: Magic Start 0 (0x0A324655)
 *   Offset 0x04: Magic Start 1 (0x9E5D5157)
 *   Offset 0x08: Flags (0x00002000 = family ID present)
 *   Offset 0x0C: Target Address (where to load in flash)
 *   Offset 0x10: Payload Size (256 bytes)
 *   Offset 0x14: Block Number (sequential index)
 *   Offset 0x18: Total Blocks (64 total)
 *   Offset 0x1C: Family ID (0xE48BFF56 = RP2040)
 *   Offset 0x20: Data Payload (256 bytes)
 *   Offset 0x1FC: Magic End (0x0AB16F30)
 */

#include <stdint.h>

// UF2 Constants
#define UF2_MAGIC_START0    0x0A324655
#define UF2_MAGIC_START1    0x9E5D5157
#define UF2_MAGIC_END       0x0AB16F30
#define UF2_FLAG_FAMILY_ID  0x00002000
#define RP2040_FAMILY_ID    0xE48BFF56

#define FLASH_BASE          0x10000000
#define TARGET_OFFSET       0x00F00000  // 15MB offset
#define PAYLOAD_SIZE        256
#define TOTAL_BLOCKS        64

// Helper macro to create a UF2 block at compile time
#define UF2_BLOCK(block_num, target_addr) { \
    /* Magic Start 0 */ UF2_MAGIC_START0, \
    /* Magic Start 1 */ UF2_MAGIC_START1, \
    /* Flags */ UF2_FLAG_FAMILY_ID, \
    /* Target Address */ (target_addr), \
    /* Payload Size */ PAYLOAD_SIZE, \
    /* Block Number */ (block_num), \
    /* Total Blocks */ TOTAL_BLOCKS, \
    /* Family ID */ RP2040_FAMILY_ID, \
    /* Payload: 256 bytes of 0xFF (64 words) */ \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, \
    /* Padding to fill to 512 bytes (52 words of 0x00) */ \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    0x00000000, 0x00000000, 0x00000000, 0x00000000, \
    /* Magic End */ UF2_MAGIC_END \
}

// UF2 test data array - placed in .UF2 section
const uint32_t uf2_test_data[] __attribute__((section(".UF2"))) = {
    // Blocks 0-15: Target 0x10F00000 (15MB offset, 4KB contiguous)
    UF2_BLOCK(0,  FLASH_BASE + TARGET_OFFSET + 0x0000),
    UF2_BLOCK(1,  FLASH_BASE + TARGET_OFFSET + 0x0100),
    UF2_BLOCK(2,  FLASH_BASE + TARGET_OFFSET + 0x0200),
    UF2_BLOCK(3,  FLASH_BASE + TARGET_OFFSET + 0x0300),
    UF2_BLOCK(4,  FLASH_BASE + TARGET_OFFSET + 0x0400),
    UF2_BLOCK(5,  FLASH_BASE + TARGET_OFFSET + 0x0500),
    UF2_BLOCK(6,  FLASH_BASE + TARGET_OFFSET + 0x0600),
    UF2_BLOCK(7,  FLASH_BASE + TARGET_OFFSET + 0x0700),
    UF2_BLOCK(8,  FLASH_BASE + TARGET_OFFSET + 0x0800),
    UF2_BLOCK(9,  FLASH_BASE + TARGET_OFFSET + 0x0900),
    UF2_BLOCK(10, FLASH_BASE + TARGET_OFFSET + 0x0A00),
    UF2_BLOCK(11, FLASH_BASE + TARGET_OFFSET + 0x0B00),
    UF2_BLOCK(12, FLASH_BASE + TARGET_OFFSET + 0x0C00),
    UF2_BLOCK(13, FLASH_BASE + TARGET_OFFSET + 0x0D00),
    UF2_BLOCK(14, FLASH_BASE + TARGET_OFFSET + 0x0E00),
    UF2_BLOCK(15, FLASH_BASE + TARGET_OFFSET + 0x0F00),

    // Blocks 16-31: Target 0x10F01000 (4KB contiguous with blocks 0-15)
    UF2_BLOCK(16, FLASH_BASE + TARGET_OFFSET + 0x1000),
    UF2_BLOCK(17, FLASH_BASE + TARGET_OFFSET + 0x1100),
    UF2_BLOCK(18, FLASH_BASE + TARGET_OFFSET + 0x1200),
    UF2_BLOCK(19, FLASH_BASE + TARGET_OFFSET + 0x1300),
    UF2_BLOCK(20, FLASH_BASE + TARGET_OFFSET + 0x1400),
    UF2_BLOCK(21, FLASH_BASE + TARGET_OFFSET + 0x1500),
    UF2_BLOCK(22, FLASH_BASE + TARGET_OFFSET + 0x1600),
    UF2_BLOCK(23, FLASH_BASE + TARGET_OFFSET + 0x1700),
    UF2_BLOCK(24, FLASH_BASE + TARGET_OFFSET + 0x1800),
    UF2_BLOCK(25, FLASH_BASE + TARGET_OFFSET + 0x1900),
    UF2_BLOCK(26, FLASH_BASE + TARGET_OFFSET + 0x1A00),
    UF2_BLOCK(27, FLASH_BASE + TARGET_OFFSET + 0x1B00),
    UF2_BLOCK(28, FLASH_BASE + TARGET_OFFSET + 0x1C00),
    UF2_BLOCK(29, FLASH_BASE + TARGET_OFFSET + 0x1D00),
    UF2_BLOCK(30, FLASH_BASE + TARGET_OFFSET + 0x1E00),
    UF2_BLOCK(31, FLASH_BASE + TARGET_OFFSET + 0x1F00),

    // Blocks 32-47: Target 0x10F03000 (4KB gap: skips 0x10F02000)
    UF2_BLOCK(32, FLASH_BASE + TARGET_OFFSET + 0x3000),
    UF2_BLOCK(33, FLASH_BASE + TARGET_OFFSET + 0x3100),
    UF2_BLOCK(34, FLASH_BASE + TARGET_OFFSET + 0x3200),
    UF2_BLOCK(35, FLASH_BASE + TARGET_OFFSET + 0x3300),
    UF2_BLOCK(36, FLASH_BASE + TARGET_OFFSET + 0x3400),
    UF2_BLOCK(37, FLASH_BASE + TARGET_OFFSET + 0x3500),
    UF2_BLOCK(38, FLASH_BASE + TARGET_OFFSET + 0x3600),
    UF2_BLOCK(39, FLASH_BASE + TARGET_OFFSET + 0x3700),
    UF2_BLOCK(40, FLASH_BASE + TARGET_OFFSET + 0x3800),
    UF2_BLOCK(41, FLASH_BASE + TARGET_OFFSET + 0x3900),
    UF2_BLOCK(42, FLASH_BASE + TARGET_OFFSET + 0x3A00),
    UF2_BLOCK(43, FLASH_BASE + TARGET_OFFSET + 0x3B00),
    UF2_BLOCK(44, FLASH_BASE + TARGET_OFFSET + 0x3C00),
    UF2_BLOCK(45, FLASH_BASE + TARGET_OFFSET + 0x3D00),
    UF2_BLOCK(46, FLASH_BASE + TARGET_OFFSET + 0x3E00),
    UF2_BLOCK(47, FLASH_BASE + TARGET_OFFSET + 0x3F00),

    // Blocks 48-63: Target 0x10F06000 (8KB gap: skips 0x10F04000 and 0x10F05000)
    UF2_BLOCK(48, FLASH_BASE + TARGET_OFFSET + 0x6000),
    UF2_BLOCK(49, FLASH_BASE + TARGET_OFFSET + 0x6100),
    UF2_BLOCK(50, FLASH_BASE + TARGET_OFFSET + 0x6200),
    UF2_BLOCK(51, FLASH_BASE + TARGET_OFFSET + 0x6300),
    UF2_BLOCK(52, FLASH_BASE + TARGET_OFFSET + 0x6400),
    UF2_BLOCK(53, FLASH_BASE + TARGET_OFFSET + 0x6500),
    UF2_BLOCK(54, FLASH_BASE + TARGET_OFFSET + 0x6600),
    UF2_BLOCK(55, FLASH_BASE + TARGET_OFFSET + 0x6700),
    UF2_BLOCK(56, FLASH_BASE + TARGET_OFFSET + 0x6800),
    UF2_BLOCK(57, FLASH_BASE + TARGET_OFFSET + 0x6900),
    UF2_BLOCK(58, FLASH_BASE + TARGET_OFFSET + 0x6A00),
    UF2_BLOCK(59, FLASH_BASE + TARGET_OFFSET + 0x6B00),
    UF2_BLOCK(60, FLASH_BASE + TARGET_OFFSET + 0x6C00),
    UF2_BLOCK(61, FLASH_BASE + TARGET_OFFSET + 0x6D00),
    UF2_BLOCK(62, FLASH_BASE + TARGET_OFFSET + 0x6E00),
    UF2_BLOCK(63, FLASH_BASE + TARGET_OFFSET + 0x6F00)
};

// Size of the UF2 data array
const uint32_t uf2_test_data_size = sizeof(uf2_test_data);
