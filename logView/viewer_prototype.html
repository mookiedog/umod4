<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>umod4 Log Viewer - Prototype v1.6</title>
    <!-- Version 1.6 - Added event name alignment with nbsp padding -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #495057;
            user-select: none;
        }

        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }

        .search-container {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .search-input {
            border: none;
            outline: none;
            padding: 5px;
            font-size: 14px;
            width: 200px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .search-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px 8px;
            color: #495057;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .search-btn:hover:not(:disabled) {
            background: #f8f9fa;
        }

        .search-btn:disabled {
            color: #dee2e6;
            cursor: not-allowed;
        }

        .search-count {
            font-size: 12px;
            color: #6c757d;
            white-space: nowrap;
        }

        .search-highlight {
            background-color: #fff3cd;
            color: #856404;
            padding: 2px 0;
        }

        .search-highlight-current {
            background-color: #ffc107;
            color: #000;
            font-weight: bold;
            padding: 2px 0;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .file-input {
            display: none;
        }

        .drop-zone {
            margin: 20px;
            padding: 40px;
            border: 3px dashed #dee2e6;
            border-radius: 8px;
            text-align: center;
            background: #f8f9fa;
            transition: all 0.3s;
        }

        .drop-zone.dragover {
            border-color: #667eea;
            background: #e7eaff;
        }

        .drop-zone p {
            color: #6c757d;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .drop-zone .icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid #dee2e6;
            background: #f8f9fa;
            padding: 0 20px;
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            font-weight: 600;
            color: #6c757d;
        }

        .tab:hover {
            color: #495057;
            background: #e9ecef;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .content {
            display: none;
            padding: 20px;
        }

        .content.active {
            display: block;
        }

        .text-output {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
        }

        .text-output .record {
            margin-bottom: 2px;
        }

        .text-output .timestamp {
            color: #4ec9b0;
        }

        .text-output .event {
            color: #dcdcaa;
        }

        .text-output .value {
            color: #ce9178;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }

        .stat-card .label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .stat-card .value {
            font-size: 24px;
            font-weight: bold;
            color: #212529;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 20px;
            border-left: 4px solid #f5c6cb;
        }

        .graph-placeholder {
            text-align: center;
            padding: 60px;
            color: #6c757d;
        }

        .graph-placeholder .icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .recent-file-item {
            padding: 10px;
            margin-bottom: 5px;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .recent-file-item:hover {
            background: #e7eaff;
            transform: translateX(5px);
        }

        .recent-file-name {
            font-weight: 600;
            color: #495057;
        }

        .recent-file-info {
            font-size: 12px;
            color: #6c757d;
            margin-top: 3px;
        }

        .recent-file-remove {
            color: #dc3545;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
        }

        .recent-file-remove:hover {
            background: #f8d7da;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèçÔ∏è umod4 Log Viewer</h1>
            <p>Motorcycle Data Logger Visualization Tool - Prototype v1.6</p>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                üìÅ Open Log File
            </button>
            <input type="file" id="fileInput" class="file-input">

            <button class="btn btn-secondary" id="recentBtn" onclick="toggleRecentFiles()">
                üïí Recent Files
            </button>

            <button class="btn btn-secondary" id="clearBtn" onclick="clearLog()" disabled>
                üóëÔ∏è Clear
            </button>

            <label class="checkbox-label">
                <input type="checkbox" id="showBinaryCheckbox" onchange="handleBinaryDisplayToggle()" checked>
                Show Binary Data
            </label>

            <div class="search-container">
                <span style="color: #6c757d;">üîç</span>
                <input type="text" id="searchInput" class="search-input" placeholder="Search..." onkeyup="handleSearchKeyup(event)">
                <button class="search-btn" id="searchPrevBtn" onclick="searchPrevious()" title="Previous (Shift+Enter)" disabled>‚ñ≤</button>
                <button class="search-btn" id="searchNextBtn" onclick="searchNext()" title="Next (Enter)" disabled>‚ñº</button>
                <span id="searchCount" class="search-count"></span>
                <button class="search-btn" id="searchClearBtn" onclick="clearSearch()" title="Clear search" style="display: none;">‚úï</button>
            </div>

            <span id="fileInfo" style="margin-left: auto; color: #6c757d;"></span>
        </div>

        <div id="recentFilesPanel" style="display: none; padding: 20px; background: #f8f9fa; border-bottom: 1px solid #dee2e6;">
            <h3 style="margin-bottom: 15px; font-size: 16px;">Recent Files</h3>
            <div id="recentFilesList"></div>
        </div>

        <div id="dropZone" class="drop-zone">
            <div class="icon">üìÇ</div>
            <p><strong>Drop log file here</strong> or click "Open Log File" button</p>
            <p style="font-size: 14px;">Supported formats: .bin (binary log files)</p>
        </div>

        <div id="tabsContainer" style="display: none;">
            <div class="tabs">
                <div class="tab active" data-tab="text" onclick="switchTab('text')">
                    üìÑ Text View
                </div>
                <div class="tab" data-tab="graph" onclick="switchTab('graph')">
                    üìä Graph View (Coming Soon)
                </div>
            </div>

            <div id="textContent" class="content active">
                <div class="stats">
                    <div class="stat-card">
                        <div class="label">File Size</div>
                        <div class="value" id="statFileSize">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Events Decoded</div>
                        <div class="value" id="statEvents">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Duration</div>
                        <div class="value" id="statDuration">-</div>
                    </div>
                    <div class="stat-card">
                        <div class="label">Processing Time</div>
                        <div class="value" id="statProcessTime">-</div>
                    </div>
                </div>

                <div class="text-output" id="textOutput">
                    <div style="color: #6c757d; text-align: center; padding: 40px;">
                        No log file loaded
                    </div>
                </div>
            </div>

            <div id="graphContent" class="content">
                <div class="graph-placeholder">
                    <div class="icon">üìä</div>
                    <h3>Graph View - Coming Soon</h3>
                    <p>Interactive time-series visualization will be added in the next version</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let showBinaryData = true;  // Default to showing binary data
        let currentParsedData = null;

        // Search state
        let searchMatches = [];
        let currentMatchIndex = -1;
        let lastSearchTerm = '';

        // Binary display configuration
        const BYTES_PER_LINE = 4;  // Number of bytes to display per line in binary mode

        // Log ID definitions (from log_base.h, ECU_log.h, EP_log.h, WP_log.h)
        const LOGID = {
            // Base addresses
            GEN_BASE: 0x00,
            ECU_BASE: 0x10,
            EP_BASE: 0xD0,
            WP_BASE: 0xE0,

            // General IDs
            GEN_ECU_LOG_VER: 0x01,
            GEN_EP_LOG_VER: 0x02,
            GEN_WP_LOG_VER: 0x03,

            // ECU IDs (complete list from ECU_log.h)
            ECU_CPU_EVENT: 0x10,
            ECU_T1_OFLO: 0x12,
            ECU_L4000_EVENT: 0x18,
            ECU_T1_HOFLO: 0x1E,
            ECU_F_INJ_ON: 0x20,
            ECU_F_INJ_DUR: 0x22,
            ECU_R_INJ_ON: 0x24,
            ECU_R_INJ_DUR: 0x26,
            ECU_F_COIL_ON: 0x30,
            ECU_F_COIL_OFF: 0x32,
            ECU_R_COIL_ON: 0x34,
            ECU_R_COIL_OFF: 0x36,
            ECU_F_COIL_MAN_ON: 0x38,
            ECU_F_COIL_MAN_OFF: 0x3A,
            ECU_R_COIL_MAN_ON: 0x3C,
            ECU_R_COIL_MAN_OFF: 0x3E,
            ECU_F_IGN_DLY: 0x40,
            ECU_R_IGN_DLY: 0x42,
            ECU_5MILLISEC_EVENT: 0x48,
            ECU_CRANK_P6_MAX: 0x49,
            ECU_FUEL_PUMP: 0x4A,
            ECU_ERROR_L000C: 0x50,
            ECU_ERROR_L000D: 0x51,
            ECU_ERROR_L000E: 0x52,
            ECU_ERROR_L000F: 0x53,
            ECU_RAW_VTA: 0x60,
            ECU_RAW_MAP: 0x62,
            ECU_RAW_AAP: 0x63,
            ECU_RAW_THW: 0x64,
            ECU_RAW_THA: 0x65,
            ECU_RAW_VM: 0x66,
            ECU_PORTG_DB: 0x67,
            ECU_CRANKREF_START: 0x70,
            ECU_CRANKREF_ID: 0x72,
            ECU_CAM_ERR: 0x73,
            ECU_CAMSHAFT: 0x74,
            ECU_SPRK_X1: 0x80,
            ECU_SPRK_X2: 0x82,
            ECU_NOSPARK: 0x84,

            // EP IDs
            EP_LOAD_NAME: 0xD0,
            EP_LOAD_ADDR: 0xD2,
            EP_LOAD_LEN: 0xD4,
            EP_LOAD_ERR: 0xD6,

            // WP IDs (complete list from WP_log.h)
            WP_CSECS: 0xE1,
            WP_SECS: 0xE2,
            WP_MINS: 0xE3,
            WP_HOURS: 0xE4,
            WP_DATE: 0xE5,
            WP_MONTH: 0xE6,
            WP_YEAR: 0xE7,
            WP_FIXTYPE: 0xE8,
            WP_GPS_POSN: 0xE9,
            WP_GPS_VELO: 0xEA,
            WP_GPS_PPS: 0xEB,
            WP_WR_TIME: 0xEB,     // Same as GPS_PPS in header (0x0B)
            WP_SYNC_TIME: 0xEC,
        };

        // CPU Event names
        const ECU_CPU_EVENT_NAMES = {
            0x0: 'RTI',
            0x1: 'IRQ',
            0x2: 'XIRQ',
            0x3: 'SWI',
            0x4: 'IOP',
            0x5: 'COP',
            0x6: 'CMF',
            0x7: 'RESET',
            0x8: 'OC5F',
            0x9: 'OC4F',
            0xA: 'OC3F',
            0xB: 'IC3'
        };

        // Error code names for EP_LOAD_ERR
        const EP_LOAD_ERR_NAMES = {
            0x00: 'ERR_NOERR',
            0x01: 'ERR_NOTFOUND',
            0x02: 'ERR_NONAME',
            0x03: 'ERR_CKSUMERR',
            0x04: 'ERR_VERIFYERR',
            0x05: 'ERR_BADOFFSET',
            0x06: 'ERR_BADLENGTH',
            0x07: 'ERR_NODAUGHTERBOARDKEY',
            0x08: 'ERR_NOMEMKEY',
            0x09: 'ERR_M3FAIL',
            0x0A: 'ERR_MISSINGKEYSTART',
            0x0B: 'ERR_MISSINGKEYLENGTH',
            0x0C: 'ERR_MISSINGKEYM3',
            0x0D: 'ERR_BADM3BSONTYPE',
            0x0E: 'ERR_BADM3VALUE',
            0x0F: 'ERR_NOBINKEY',
            0x10: 'ERR_BADBINLENGTH',
            0x11: 'ERR_BADBINSUBTYPE'
        };

        // TimeKeeper class - reconstructs 64-bit timestamps from 16-bit samples
        class TimeKeeper {
            constructor() {
                this.time_ns = 0;
                this.prev_timestamp = -1;
                this.in_upper_half = false;
            }

            processTimestamp(raw_ts, is_oflo = false, is_hoflo = false) {
                if (this.prev_timestamp >= 0) {
                    let delta_ticks = raw_ts - this.prev_timestamp;
                    if (delta_ticks < 0) {
                        delta_ticks += 65536; // Handle 16-bit wraparound
                    }
                    // Each tick is 2 microseconds = 2000 nanoseconds
                    this.time_ns += delta_ticks * 2000;
                }
                this.prev_timestamp = raw_ts;

                // Track upper/lower half for better wraparound detection
                if (is_hoflo) {
                    this.in_upper_half = true;
                } else if (is_oflo) {
                    this.in_upper_half = false;
                }
            }

            advanceByNs(ns) {
                this.time_ns += ns;
            }

            getTimeNs() {
                return this.time_ns;
            }

            getTimeSec() {
                return this.time_ns / 1e9;
            }
        }

        // Parse the binary log
        function parseLog(data) {
            const timekeeper = new TimeKeeper();
            const records = [];  // Store records with binary data
            let recordCount = 0;
            let offset = 0;
            let byteOffset = 0;  // Track absolute byte position for binary display

            // State for EP_LOAD_NAME accumulation
            let epromNameBuffer = '';
            let epromNameBinaryData = [];  // Accumulate binary bytes for the entire string
            let epromNameStartOffset = 0;   // Track where the string started

            const view = new DataView(data.buffer);

            function formatRecord(recordNum, tk) {
                const elapsed = tk.getTimeSec();
                return `[${recordNum.toString().padStart(6)}  @ ${elapsed.toFixed(4).padStart(10)}s]`;
            }

            // Helper to pad event names to 12 characters for alignment
            function padEvent(name) {
                const targetLen = 12;
                if (name.length >= targetLen) return name;
                const padding = '&nbsp;'.repeat(targetLen - name.length);
                return name + padding;
            }

            function formatBinaryData(startOffset, bytes) {
                // Format: 0xAAAAAAAA: B1 B2 B3 B4
                const hexBytes = bytes.map(b => b.toString(16).padStart(2, '0').toUpperCase());
                // Pad to 4 bytes with spaces
                while (hexBytes.length < 4) {
                    hexBytes.push('  ');
                }
                const bytesStr = hexBytes.join(' ');
                return `<span style="color: #569cd6;">0x${startOffset.toString(16).padStart(8, '0')}: ${bytesStr}</span>`;
            }

            // Track bytes read for current event
            let currentEventBytes = [];
            let currentEventStartOffset = 0;

            function startEvent() {
                currentEventBytes = [];
                currentEventStartOffset = byteOffset;
            }

            function readU8() {
                if (offset >= data.length) return null;
                const val = data[offset++];
                byteOffset++;
                currentEventBytes.push(val);
                return val;
            }

            function readU16LE() {
                if (offset + 1 >= data.length) return null;
                const val = view.getUint16(offset, true); // little-endian
                const b1 = data[offset];
                const b2 = data[offset + 1];
                offset += 2;
                byteOffset += 2;
                currentEventBytes.push(b1, b2);
                return val;
            }

            function readI16LE() {
                if (offset + 1 >= data.length) return null;
                const val = view.getInt16(offset, true); // little-endian
                const b1 = data[offset];
                const b2 = data[offset + 1];
                offset += 2;
                byteOffset += 2;
                currentEventBytes.push(b1, b2);
                return val;
            }

            function readBytes(n) {
                if (offset + n > data.length) return null;
                const bytes = data.slice(offset, offset + n);
                for (let i = 0; i < n; i++) {
                    currentEventBytes.push(data[offset + i]);
                }
                offset += n;
                byteOffset += n;
                return bytes;
            }

            // Process all events - no limit for performance testing
            // Note: Large log files (>100k events) may cause browser slowdown
            const MAX_EVENTS = Infinity;

            while (offset < data.length && recordCount < MAX_EVENTS) {
                startEvent();  // Begin tracking bytes for this event
                const logid = readU8();
                if (logid === null) break;

                recordCount++;
                const prefix = formatRecord(recordCount, timekeeper);
                let line = '';

                switch (logid) {
                    // ===== GENERAL IDs =====
                    case LOGID.GEN_ECU_LOG_VER:
                        line = `${prefix}: <span class="event">${padEvent('ECU_VER')}</span>: <span class="value">${readU8()}</span>`;
                        break;

                    case LOGID.GEN_EP_LOG_VER:
                        line = `${prefix}: <span class="event">${padEvent('EP_VER')}</span>: <span class="value">${readU8()}</span>`;
                        break;

                    case LOGID.GEN_WP_LOG_VER:
                        line = `${prefix}: <span class="event">${padEvent('WP_VER')}</span>: <span class="value">${readU8()}</span>`;
                        break;

                    // ===== ECU IDs =====
                    case LOGID.ECU_CPU_EVENT: {
                        const evt = readU8();
                        const evtName = ECU_CPU_EVENT_NAMES[evt] || `UNKNOWN(${evt})`;
                        line = `${prefix}: <span class="event">${padEvent('CPU_EVT')}</span>: <span class="value">${evtName}</span>`;
                        timekeeper.advanceByNs(1);
                        break;
                    }

                    case LOGID.ECU_T1_OFLO: {
                        const oflo_ts = readU16LE();
                        timekeeper.processTimestamp(oflo_ts, true, false);
                        line = `${prefix}: <span class="event">${padEvent('OFLO')}</span>: <span class="value">${oflo_ts}</span>`;
                        break;
                    }

                    case LOGID.ECU_L4000_EVENT:
                        line = `${prefix}: <span class="event">${padEvent('L4000')}</span>:   <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_T1_HOFLO: {
                        const hoflo_ts = readU16LE();
                        timekeeper.processTimestamp(hoflo_ts, false, true);
                        line = `${prefix}: <span class="event">${padEvent('HOFLO')}</span>: <span class="value">${hoflo_ts}</span>`;
                        break;
                    }

                    // Injector events
                    case LOGID.ECU_F_INJ_ON:
                        line = `${prefix}: <span class="event">${padEvent('FI_ON')}</span>:   <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_F_INJ_DUR:
                        line = `${prefix}: <span class="event">${padEvent('FI_DUR')}</span>:  <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_R_INJ_ON:
                        line = `${prefix}: <span class="event">${padEvent('RI_ON')}</span>:   <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_R_INJ_DUR:
                        line = `${prefix}: <span class="event">${padEvent('RI_DUR')}</span>:  <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    // Coil events
                    case LOGID.ECU_F_COIL_ON:
                        line = `${prefix}: <span class="event">${padEvent('FC_ON')}</span>:   <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_F_COIL_OFF:
                        line = `${prefix}: <span class="event">${padEvent('FC_OFF')}</span>:  <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_R_COIL_ON:
                        line = `${prefix}: <span class="event">${padEvent('RC_ON')}</span>:   <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_R_COIL_OFF:
                        line = `${prefix}: <span class="event">${padEvent('RC_OFF')}</span>:  <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_F_COIL_MAN_ON:
                        line = `${prefix}: <span class="event">${padEvent('FC_MAN_ON')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_F_COIL_MAN_OFF:
                        line = `${prefix}: <span class="event">${padEvent('FC_MAN_OFF')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_R_COIL_MAN_ON:
                        line = `${prefix}: <span class="event">${padEvent('RC_MAN_ON')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_R_COIL_MAN_OFF:
                        line = `${prefix}: <span class="event">${padEvent('RC_MAN_OFF')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    // Ignition delay
                    case LOGID.ECU_F_IGN_DLY:
                        line = `${prefix}: <span class="event">${padEvent('F_IGN_DLY')}</span>: <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_R_IGN_DLY:
                        line = `${prefix}: <span class="event">${padEvent('R_IGN_DLY')}</span>: <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    // Other ECU events
                    case LOGID.ECU_5MILLISEC_EVENT:
                        readU8();  // Ignore garbage byte
                        line = `${prefix}: <span class="event">5MS_EVENT</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_CRANK_P6_MAX:
                        readU8();  // Ignore garbage byte
                        line = `${prefix}: <span class="event">CRANK_P6_MAX</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_FUEL_PUMP:
                        line = `${prefix}: <span class="event">${padEvent('FUEL_PUMP')}</span>: <span class="value">${readU8() ? 'ON' : 'OFF'}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    // Error events
                    case LOGID.ECU_ERROR_L000C:
                        line = `${prefix}: <span class="event">${padEvent('ERR_L000C')}</span>: <span class="value">0x${readU8().toString(16).padStart(2, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_ERROR_L000D:
                        line = `${prefix}: <span class="event">${padEvent('ERR_L000D')}</span>: <span class="value">0x${readU8().toString(16).padStart(2, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_ERROR_L000E:
                        line = `${prefix}: <span class="event">${padEvent('ERR_L000E')}</span>: <span class="value">0x${readU8().toString(16).padStart(2, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_ERROR_L000F:
                        line = `${prefix}: <span class="event">${padEvent('ERR_L000F')}</span>: <span class="value">0x${readU8().toString(16).padStart(2, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    // Sensor raw values
                    case LOGID.ECU_RAW_VTA:
                        line = `${prefix}: <span class="event">${padEvent('VTA')}</span>:     <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_RAW_MAP:
                        line = `${prefix}: <span class="event">${padEvent('MAP')}</span>:     <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_RAW_AAP:
                        line = `${prefix}: <span class="event">${padEvent('AAP')}</span>:     <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_RAW_THW:
                        line = `${prefix}: <span class="event">${padEvent('THW')}</span>:     <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_RAW_THA:
                        line = `${prefix}: <span class="event">${padEvent('THA')}</span>:     <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_RAW_VM:
                        line = `${prefix}: <span class="event">${padEvent('VM')}</span>:      <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_PORTG_DB:
                        line = `${prefix}: <span class="event">${padEvent('PORTG_DB')}</span>: <span class="value">0b${readU8().toString(2).padStart(8, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    // Crankshaft events
                    case LOGID.ECU_CRANKREF_START: {
                        const cr_ts = readU16LE();
                        timekeeper.processTimestamp(cr_ts, false, false);
                        line = `${prefix}: <span class="event">${padEvent('CRANK_TS')}</span>: <span class="value">${cr_ts}</span>`;
                        break;
                    }

                    case LOGID.ECU_CRANKREF_ID:
                        line = `${prefix}: <span class="event">${padEvent('CRID')}</span>: <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_CAM_ERR:
                        line = `${prefix}: <span class="event">${padEvent('CAM_ERR')}</span>: <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_CAMSHAFT: {
                        const cam_ts = readU16LE();
                        timekeeper.processTimestamp(cam_ts, false, false);
                        line = `${prefix}: <span class="event">${padEvent('CAM_TS')}</span>: <span class="value">${cam_ts}</span>`;
                        break;
                    }

                    // Spark events
                    case LOGID.ECU_SPRK_X1:
                        line = `${prefix}: <span class="event">${padEvent('SPRK_X1')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_SPRK_X2:
                        line = `${prefix}: <span class="event">${padEvent('SPRK_X2')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.ECU_NOSPARK:
                        line = `${prefix}: <span class="event">${padEvent('NOSPARK')}</span>: <span class="value">0x${readU8().toString(16).padStart(2, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    // ===== EP Events =====
                    case LOGID.EP_LOAD_NAME: {
                        const ch = readU8();

                        // If this is the first character, record the start offset
                        if (epromNameBuffer === '') {
                            epromNameStartOffset = currentEventStartOffset;
                            epromNameBinaryData = [];
                        }

                        // Accumulate the binary data for this character (LOGID + char byte)
                        epromNameBinaryData.push(...currentEventBytes);

                        if (ch === 0) {
                            // NULL terminator - emit the complete name with all accumulated binary data
                            line = `${prefix}: <span class="event">${padEvent('LOAD')}</span>:    <span class="value">${epromNameBuffer}</span>`;

                            // Create a record with ALL the accumulated binary data
                            if (line) {
                                records.push({
                                    html: line,
                                    binData: epromNameBinaryData.slice(),
                                    binOffset: epromNameStartOffset
                                });
                                recordCount++;
                                if (recordCount >= MAX_EVENTS) break;
                                line = '';  // Clear so we don't add it again below
                            }

                            epromNameBuffer = '';
                            epromNameBinaryData = [];
                        } else {
                            // Accumulate character - don't output line yet
                            epromNameBuffer += String.fromCharCode(ch);
                            // Clear line so this event doesn't create a record yet
                            line = '';
                        }
                        timekeeper.advanceByNs(1);
                        break;
                    }

                    case LOGID.EP_LOAD_ADDR: {
                        const addr = readU16LE();
                        line = `${prefix}: <span class="event">${padEvent('ADDR')}</span>:    <span class="value">0x${addr.toString(16).padStart(4, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;
                    }

                    case LOGID.EP_LOAD_LEN: {
                        const len = readU16LE();
                        line = `${prefix}: <span class="event">${padEvent('LEN')}</span>:     <span class="value">0x${len.toString(16).padStart(4, '0')}</span>`;
                        timekeeper.advanceByNs(1);
                        break;
                    }

                    case LOGID.EP_LOAD_ERR: {
                        const err = readU8();
                        const errName = EP_LOAD_ERR_NAMES[err] || `UNKNOWN(${err})`;
                        line = `${prefix}: <span class="event">${padEvent('STAT')}</span>:    <span class="value">${errName}</span>`;
                        timekeeper.advanceByNs(1);
                        break;
                    }

                    // ===== WP Events =====
                    case LOGID.WP_CSECS:
                        line = `${prefix}: <span class="event">${padEvent('CSECS')}</span>:   <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_SECS:
                        line = `${prefix}: <span class="event">${padEvent('SECS')}</span>:    <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_MINS:
                        line = `${prefix}: <span class="event">${padEvent('MINS')}</span>:    <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_HOURS:
                        line = `${prefix}: <span class="event">${padEvent('HOURS')}</span>:   <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_DATE:
                        line = `${prefix}: <span class="event">${padEvent('DATE')}</span>:    <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_MONTH:
                        line = `${prefix}: <span class="event">${padEvent('MONTH')}</span>:   <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_YEAR:
                        line = `${prefix}: <span class="event">${padEvent('YEAR')}</span>:    <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_FIXTYPE:
                        line = `${prefix}: <span class="event">${padEvent('FIXTYPE')}</span>: <span class="value">${readU8()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_GPS_POSN: {
                        const posBytes = readBytes(8);  // 4 bytes lat + 4 bytes long
                        const lat = new DataView(posBytes.buffer).getInt32(0, true);
                        const lon = new DataView(posBytes.buffer).getInt32(4, true);
                        line = `${prefix}: <span class="event">${padEvent('GPS_POSN')}</span>: <span class="value">lat=${lat} lon=${lon}</span>`;
                        timekeeper.advanceByNs(1);
                        break;
                    }

                    case LOGID.WP_GPS_VELO:
                        line = `${prefix}: <span class="event">${padEvent('GPS_VELO')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_GPS_PPS:
                        line = `${prefix}: <span class="event">GPS_PPS</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    case LOGID.WP_SYNC_TIME:
                        line = `${prefix}: <span class="event">${padEvent('SYNC_TIME')}</span>: <span class="value">${readU16LE()}</span>`;
                        timekeeper.advanceByNs(1);
                        break;

                    default:
                        // Unknown event - try to skip it
                        line = `${prefix}: <span style="color: #ff6b6b;">UNKNOWN(0x${logid.toString(16).padStart(2, '0')})</span>`;
                        timekeeper.advanceByNs(1);
                        break;
                }

                if (line) {
                    records.push({
                        html: line,
                        binData: currentEventBytes.slice(),
                        binOffset: currentEventStartOffset
                    });
                }
            }

            return {
                records: records,
                recordCount: recordCount,
                duration: timekeeper.getTimeSec(),
                truncated: recordCount >= MAX_EVENTS
            };
        }

        // Render records with optional binary display
        function renderRecords(parsedData, showBinary) {
            const output = [];

            for (const record of parsedData.records) {
                if (showBinary && record.binData.length > 0) {
                    // Format binary data with proper multi-line support
                    const binLines = formatBinaryDataForRecord(record.binOffset, record.binData);
                    const binLineArray = binLines.split('\n');

                    // First line gets the record html appended
                    output.push(`<div class="record">${binLineArray[0]} ${record.html}</div>`);

                    // Additional lines (for multi-byte events) are standalone
                    for (let i = 1; i < binLineArray.length; i++) {
                        output.push(`<div class="record">${binLineArray[i]}</div>`);
                    }
                } else {
                    output.push(`<div class="record">${record.html}</div>`);
                }
            }

            return output.join('');
        }

        function formatBinaryDataForRecord(startOffset, bytes) {
            // Format BYTES_PER_LINE bytes per line: 0xAAAAAAAA: B1 B2 B3 B4
            const chunks = [];
            for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
                const chunk = bytes.slice(i, Math.min(i + BYTES_PER_LINE, bytes.length));
                const hexBytes = chunk.map(b => b.toString(16).padStart(2, '0').toUpperCase());

                // Pad with nbsp entities (2 chars per missing byte for alignment)
                // This ensures timing info is vertically aligned (HTML collapses regular spaces)
                while (hexBytes.length < BYTES_PER_LINE) {
                    hexBytes.push('&nbsp;&nbsp;');  // Two nbsp entities to represent missing byte
                }

                const bytesStr = hexBytes.join(' ');
                const addr = (startOffset + i).toString(16).padStart(8, '0');
                chunks.push(`<span style="color: #569cd6;">0x${addr}: ${bytesStr}</span>`);
            }
            return chunks.join('\n');
        }

        // Handle binary display toggle
        function handleBinaryDisplayToggle() {
            showBinaryData = document.getElementById('showBinaryCheckbox').checked;

            if (currentParsedData) {
                // Re-render with current setting
                let html = renderRecords(currentParsedData, showBinaryData);

                if (currentParsedData.truncated) {
                    html += `<div style="color: #ffa500; margin-top: 20px; text-align: center;">‚ö†Ô∏è Output limited to ${currentParsedData.recordCount.toLocaleString()} events for performance</div>`;
                }

                document.getElementById('textOutput').innerHTML = html;

                // Re-apply search highlighting if there was an active search
                if (lastSearchTerm) {
                    performSearch(lastSearchTerm);
                }
            }
        }

        // Search functionality
        function handleSearchKeyup(event) {
            if (event.key === 'Enter') {
                if (event.shiftKey) {
                    searchPrevious();
                } else {
                    searchNext();
                }
            } else {
                const searchTerm = document.getElementById('searchInput').value;
                if (searchTerm !== lastSearchTerm) {
                    performSearch(searchTerm);
                }
            }
        }

        function performSearch(searchTerm) {
            lastSearchTerm = searchTerm;
            searchMatches = [];
            currentMatchIndex = -1;

            const outputDiv = document.getElementById('textOutput');
            const records = outputDiv.querySelectorAll('.record');

            if (!searchTerm || searchTerm.length === 0) {
                // Clear all highlights
                records.forEach(record => {
                    record.innerHTML = record.innerHTML
                        .replace(/<mark class="search-highlight-current">(.+?)<\/mark>/g, '$1')
                        .replace(/<mark class="search-highlight">(.+?)<\/mark>/g, '$1');
                });
                updateSearchUI();
                return;
            }

            // Search through all records (case-insensitive)
            const searchRegex = new RegExp(escapeRegExp(searchTerm), 'gi');

            records.forEach((record, index) => {
                // Get text content without HTML tags for searching
                const textContent = record.textContent || record.innerText;

                if (searchRegex.test(textContent)) {
                    searchMatches.push(index);
                }
            });

            if (searchMatches.length > 0) {
                currentMatchIndex = 0;
                highlightMatches(searchTerm);
                scrollToCurrentMatch();
            }

            updateSearchUI();
        }

        function highlightMatches(searchTerm) {
            const outputDiv = document.getElementById('textOutput');
            const records = outputDiv.querySelectorAll('.record');

            records.forEach((record, index) => {
                // First, remove any existing highlights
                let html = record.innerHTML
                    .replace(/<mark class="search-highlight-current">(.+?)<\/mark>/g, '$1')
                    .replace(/<mark class="search-highlight">(.+?)<\/mark>/g, '$1');

                record.innerHTML = html;

                // Check if this record contains a match
                if (searchMatches.includes(index)) {
                    const isCurrent = (index === searchMatches[currentMatchIndex]);

                    // Use a safer approach: walk the text nodes and highlight them
                    highlightTextNodes(record, searchTerm, isCurrent);
                }
            });
        }

        function highlightTextNodes(element, searchTerm, isCurrent) {
            const highlightClass = isCurrent ? 'search-highlight-current' : 'search-highlight';
            const searchRegex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');

            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            const nodesToReplace = [];
            let node;

            // Collect all text nodes that contain matches
            while (node = walker.nextNode()) {
                if (searchRegex.test(node.textContent)) {
                    nodesToReplace.push(node);
                }
            }

            // Replace text nodes with highlighted versions
            nodesToReplace.forEach(textNode => {
                const text = textNode.textContent;
                const fragment = document.createDocumentFragment();
                let lastIndex = 0;
                const regex = new RegExp(escapeRegExp(searchTerm), 'gi');
                let match;

                while ((match = regex.exec(text)) !== null) {
                    // Add text before match
                    if (match.index > lastIndex) {
                        fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                    }

                    // Add highlighted match
                    const mark = document.createElement('mark');
                    mark.className = highlightClass;
                    mark.textContent = match[0];
                    fragment.appendChild(mark);

                    lastIndex = regex.lastIndex;
                }

                // Add remaining text
                if (lastIndex < text.length) {
                    fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
                }

                textNode.parentNode.replaceChild(fragment, textNode);
            });
        }

        function scrollToCurrentMatch() {
            if (currentMatchIndex >= 0 && currentMatchIndex < searchMatches.length) {
                const outputDiv = document.getElementById('textOutput');
                const records = outputDiv.querySelectorAll('.record');
                const currentRecord = records[searchMatches[currentMatchIndex]];

                if (currentRecord) {
                    currentRecord.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        function searchNext() {
            if (searchMatches.length === 0) return;

            currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
            highlightMatches(lastSearchTerm);
            scrollToCurrentMatch();
            updateSearchUI();
        }

        function searchPrevious() {
            if (searchMatches.length === 0) return;

            currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
            highlightMatches(lastSearchTerm);
            scrollToCurrentMatch();
            updateSearchUI();
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            performSearch('');
        }

        function updateSearchUI() {
            const hasResults = searchMatches.length > 0;
            const hasSearch = lastSearchTerm.length > 0;

            document.getElementById('searchPrevBtn').disabled = !hasResults;
            document.getElementById('searchNextBtn').disabled = !hasResults;
            document.getElementById('searchClearBtn').style.display = hasSearch ? 'block' : 'none';

            const countSpan = document.getElementById('searchCount');
            if (hasResults) {
                countSpan.textContent = `${currentMatchIndex + 1}/${searchMatches.length}`;
            } else if (hasSearch) {
                countSpan.textContent = 'No matches';
            } else {
                countSpan.textContent = '';
            }
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Recent Files Management
        const MAX_RECENT_FILES = 10;

        function getRecentFiles() {
            const stored = localStorage.getItem('recentFiles');
            return stored ? JSON.parse(stored) : [];
        }

        function addRecentFile(fileName, fileSize) {
            let recent = getRecentFiles();

            // Remove if already exists
            recent = recent.filter(f => f.name !== fileName);

            // Add to front
            recent.unshift({
                name: fileName,
                size: fileSize,
                timestamp: Date.now()
            });

            // Keep only MAX_RECENT_FILES
            recent = recent.slice(0, MAX_RECENT_FILES);

            localStorage.setItem('recentFiles', JSON.stringify(recent));
            updateRecentFilesList();
        }

        function removeRecentFile(fileName) {
            let recent = getRecentFiles();
            recent = recent.filter(f => f.name !== fileName);
            localStorage.setItem('recentFiles', JSON.stringify(recent));
            updateRecentFilesList();
        }

        function updateRecentFilesList() {
            const recent = getRecentFiles();
            const listDiv = document.getElementById('recentFilesList');

            if (recent.length === 0) {
                listDiv.innerHTML = '<p style="color: #6c757d;">No recent files</p>';
                return;
            }

            listDiv.innerHTML = recent.map(file => {
                const date = new Date(file.timestamp);
                const timeStr = date.toLocaleString();

                return `
                    <div class="recent-file-item" onclick="openFilePicker()">
                        <div style="flex: 1;">
                            <div class="recent-file-name">${file.name}</div>
                            <div class="recent-file-info">${formatBytes(file.size)} - ${timeStr}</div>
                        </div>
                        <span class="recent-file-remove" onclick="event.stopPropagation(); removeRecentFile('${file.name}')">‚úï</span>
                    </div>
                `;
            }).join('');

            // Note about browser security
            const note = document.createElement('p');
            note.style.cssText = 'margin-top: 15px; font-size: 12px; color: #6c757d; font-style: italic;';
            note.textContent = 'Click a file name to open file picker. Due to browser security, you must manually reselect the file.';
            listDiv.appendChild(note);
        }

        function toggleRecentFiles() {
            const panel = document.getElementById('recentFilesPanel');
            if (panel.style.display === 'none') {
                updateRecentFilesList();
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function openFilePicker() {
            document.getElementById('fileInput').click();
        }

        // File handling
        function handleFile(file) {
            const startTime = performance.now();

            document.getElementById('fileInfo').textContent = `Loading ${file.name}...`;
            document.getElementById('dropZone').style.display = 'none';
            document.getElementById('recentFilesPanel').style.display = 'none';
            document.getElementById('tabsContainer').style.display = 'block';
            document.getElementById('clearBtn').disabled = false;

            // Add to recent files
            addRecentFile(file.name, file.size);

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const result = parseLog(data);
                    const processingTime = (performance.now() - startTime) / 1000;

                    // Store parsed data for re-rendering when binary display is toggled
                    currentParsedData = result;

                    // Update stats
                    document.getElementById('statFileSize').textContent = formatBytes(data.length);
                    document.getElementById('statEvents').textContent = result.recordCount.toLocaleString();
                    document.getElementById('statDuration').textContent = result.duration.toFixed(2) + 's';
                    document.getElementById('statProcessTime').textContent = processingTime.toFixed(2) + 's';

                    // Render output with current binary display setting
                    let html = renderRecords(result, showBinaryData);
                    if (result.truncated) {
                        html += `<div style="color: #ffa500; margin-top: 20px; text-align: center;">‚ö†Ô∏è Output limited to ${result.recordCount.toLocaleString()} events for performance</div>`;
                    }
                    document.getElementById('textOutput').innerHTML = html;

                    document.getElementById('fileInfo').textContent = `${file.name} (${formatBytes(data.length)})`;
                } catch (err) {
                    document.getElementById('textOutput').innerHTML = `<div class="error">Error parsing log: ${err.message}</div>`;
                    console.error(err);
                }
            };

            reader.onerror = function() {
                document.getElementById('textOutput').innerHTML = '<div class="error">Error reading file</div>';
            };

            reader.readAsArrayBuffer(file);
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function clearLog() {
            document.getElementById('dropZone').style.display = 'block';
            document.getElementById('tabsContainer').style.display = 'none';
            document.getElementById('fileInfo').textContent = '';
            document.getElementById('textOutput').innerHTML = '<div style="color: #6c757d; text-align: center; padding: 40px;">No log file loaded</div>';
            document.getElementById('clearBtn').disabled = true;
            document.getElementById('fileInput').value = '';
            currentParsedData = null;
        }

        function switchTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Update content
            document.querySelectorAll('.content').forEach(content => {
                content.classList.toggle('active', content.id === tabName + 'Content');
            });
        }

        // Set up file input
        document.getElementById('fileInput').addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Set up drag and drop
        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', function() {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');

            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        // Also allow dropping anywhere on the page
        document.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        document.addEventListener('drop', function(e) {
            e.preventDefault();
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
    </script>
</body>
</html>
