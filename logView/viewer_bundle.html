<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>umod4 Log Viewer - v2.0 Bundled (for phones/tablets)</title>
    <!-- Version 2.0 - Bundled from ES6 modules -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .controls {
            padding: 15px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #495057;
            user-select: none;
        }

        .checkbox-label input[type="checkbox"] {
            cursor: pointer;
        }

        .search-container {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .search-input {
            border: none;
            outline: none;
            padding: 5px;
            font-size: 14px;
            width: 200px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .search-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px 8px;
            color: #495057;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .search-btn:hover:not(:disabled) {
            background: #f8f9fa;
        }

        .search-btn:disabled {
            color: #dee2e6;
            cursor: not-allowed;
        }

        .search-count {
            font-size: 12px;
            color: #6c757d;
            white-space: nowrap;
        }

        .search-highlight {
            background-color: #fff3cd;
            color: #856404;
            padding: 2px 0;
        }

        .search-highlight-current {
            background-color: #ffc107;
            color: #000;
            font-weight: bold;
            padding: 2px 0;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .file-input {
            display: none;
        }

        .drop-zone {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px dashed #495057;
            border-radius: 10px;
            margin: 40px;
            background: #2d2d2d;
            transition: all 0.3s;
        }

        .drop-zone:hover {
            border-color: #667eea;
            background: #3d3d3d;
        }

        .drop-zone-content {
            text-align: center;
            padding: 40px;
        }

        .drop-zone-content h2 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #667eea;
        }

        .tabs-container {
            display: none;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .tabs {
            display: flex;
            background: #2d2d2d;
            border-bottom: 2px solid #495057;
        }

        .tab {
            padding: 12px 24px;
            cursor: pointer;
            background: #2d2d2d;
            color: #aaa;
            border: none;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .tab:hover {
            background: #3d3d3d;
            color: #fff;
        }

        .tab.active {
            background: #1e1e1e;
            color: #667eea;
            border-bottom: 2px solid #667eea;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        #textOutput {
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.6;
            background: #1e1e1e;
            overflow-y: auto;
            height: 100%;
        }

        .record {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .event {
            color: #4ec9b0;
            font-weight: bold;
        }

        .value {
            color: #ce9178;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 20px;
            background: #2d2d2d;
        }

        .stat-card {
            background: #3d3d3d;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
        }

        .graph-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #aaa;
            text-align: center;
        }

        .error {
            color: #f48771;
            padding: 20px;
            background: #f8d7da;
        }

        .progress-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .progress-box {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            min-width: 300px;
            text-align: center;
        }

        .progress-text {
            color: #fff;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #1e1e1e;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-status {
            color: #aaa;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- Progress overlay -->
    <div id="progressOverlay" class="progress-overlay">
        <div class="progress-box">
            <div class="progress-text" id="progressText">Loading file...</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-status" id="progressStatus">0%</div>
        </div>
    </div>
    <div class="container">
        <div class="header">
            <h1>üèçÔ∏è umod4 Log Viewer</h1>
            <p>Motorcycle Data Logger Visualization Tool - v2.0 Bundled (for phones/tablets)</p>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                üìÅ Open Log File
            </button>
            <input type="file" id="fileInput" class="file-input">

            <button class="btn btn-secondary" id="recentBtn" onclick="toggleRecentFiles()">
                üïí Recent Files
            </button>

            <button class="btn btn-secondary" id="clearBtn" onclick="clearLog()" disabled>
                üóëÔ∏è Clear
            </button>

            <label class="checkbox-label">
                <input type="checkbox" id="showBinaryCheckbox" onchange="handleBinaryDisplayToggle()" checked>
                Show Binary Data
            </label>

            <div class="search-container">
                <span style="color: #6c757d;">üîç</span>
                <input type="text" id="searchInput" class="search-input" placeholder="Search..." onkeyup="handleSearchKeyup(event)">
                <button class="search-btn" id="searchPrevBtn" onclick="handleSearchPrevious()" title="Previous (Shift+Enter)" disabled>‚ñ≤</button>
                <button class="search-btn" id="searchNextBtn" onclick="handleSearchNext()" title="Next (Enter)" disabled>‚ñº</button>
                <span id="searchCount" class="search-count"></span>
                <button class="search-btn" id="searchClearBtn" onclick="handleClearSearch()" title="Clear search" style="display: none;">‚úï</button>
            </div>

            <span id="fileInfo" style="margin-left: auto; color: #6c757d;"></span>
        </div>

        <div id="recentFilesPanel" style="display: none; padding: 20px; background: #f8f9fa; border-bottom: 1px solid #dee2e6;">
            <h3 style="margin-bottom: 15px; font-size: 16px;">Recent Files</h3>
            <div id="recentFilesList"></div>
        </div>

        <div id="dropZone" class="drop-zone">
            <div class="drop-zone-content">
                <h2>Drop log file here</h2>
                <p style="color: #aaa;">or click "Open Log File" button above</p>
                <p style="color: #666; margin-top: 20px; font-size: 12px;">Supports binary .log files from umod4 logger</p>
            </div>
        </div>

        <div id="tabsContainer" class="tabs-container">
            <div class="tabs">
                <button class="tab active" data-tab="text" onclick="switchTab('text')">üìÑ Text View</button>
                <button class="tab" data-tab="graph" onclick="switchTab('graph')">üìä Graph View</button>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">File Size</div>
                    <div class="stat-value" id="statFileSize">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Events</div>
                    <div class="stat-value" id="statEvents">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Duration</div>
                    <div class="stat-value" id="statDuration">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Processing Time</div>
                    <div class="stat-value" id="statProcessTime">-</div>
                </div>
            </div>

            <div class="tab-content active" id="textTab" data-tab="text">
                <div id="textOutput"></div>
            </div>

            <div class="tab-content" id="graphTab" data-tab="graph">
                <div class="graph-placeholder">
                    <div>
                        <h3>Graph View - Coming Soon</h3>
                        <p>Interactive time-series visualization will be added in the next version</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

        // Import modules
// ===== Bundled: js/parser.js =====
// parser.js - Binary log parsing and timestamp reconstruction

// ===== Bundled: constants.js =====
// constants.js - LOGID definitions and lookup tables
// Exported from ECU_log.h, EP_log.h, WP_log.h, log_base.h

const LOGID = {
    // Base addresses
    GEN_BASE: 0x00,
    ECU_BASE: 0x10,
    EP_BASE: 0xD0,
    WP_BASE: 0xE0,

    // General IDs
    GEN_ECU_LOG_VER: 0x01,
    GEN_EP_LOG_VER: 0x02,
    GEN_WP_LOG_VER: 0x03,

    // ECU IDs (complete list from ECU_log.h)
    ECU_CPU_EVENT: 0x10,
    ECU_T1_OFLO: 0x12,
    ECU_L4000_EVENT: 0x18,
    ECU_T1_HOFLO: 0x1E,
    ECU_F_INJ_ON: 0x20,
    ECU_F_INJ_DUR: 0x22,
    ECU_R_INJ_ON: 0x24,
    ECU_R_INJ_DUR: 0x26,
    ECU_F_COIL_ON: 0x30,
    ECU_F_COIL_OFF: 0x32,
    ECU_R_COIL_ON: 0x34,
    ECU_R_COIL_OFF: 0x36,
    ECU_F_COIL_MAN_ON: 0x38,
    ECU_F_COIL_MAN_OFF: 0x3A,
    ECU_R_COIL_MAN_ON: 0x3C,
    ECU_R_COIL_MAN_OFF: 0x3E,
    ECU_F_IGN_DLY: 0x40,
    ECU_R_IGN_DLY: 0x42,
    ECU_5MILLISEC_EVENT: 0x48,
    ECU_CRANK_P6_MAX: 0x49,
    ECU_FUEL_PUMP: 0x4A,
    ECU_ERROR_L000C: 0x50,
    ECU_ERROR_L000D: 0x51,
    ECU_ERROR_L000E: 0x52,
    ECU_ERROR_L000F: 0x53,
    ECU_RAW_VTA: 0x60,
    ECU_RAW_MAP: 0x62,
    ECU_RAW_AAP: 0x63,
    ECU_RAW_THW: 0x64,
    ECU_RAW_THA: 0x65,
    ECU_RAW_VM: 0x66,
    ECU_PORTG_DB: 0x67,
    ECU_CRANKREF_START: 0x70,
    ECU_CRANKREF_ID: 0x72,
    ECU_CAM_ERR: 0x73,
    ECU_CAMSHAFT: 0x74,
    ECU_SPRK_X1: 0x80,
    ECU_SPRK_X2: 0x82,
    ECU_NOSPARK: 0x84,

    // EP IDs
    EP_LOAD_NAME: 0xD0,
    EP_FIND_NAME: 0xD1,
    EP_LOAD_ADDR: 0xD2,
    EP_LOAD_LEN: 0xD4,
    EP_LOAD_ERR: 0xD6,

    // WP IDs (complete list from WP_log.h)
    WP_CSECS: 0xE1,
    WP_SECS: 0xE2,
    WP_MINS: 0xE3,
    WP_HOURS: 0xE4,
    WP_DATE: 0xE5,
    WP_MONTH: 0xE6,
    WP_YEAR: 0xE7,
    WP_FIXTYPE: 0xE8,
    WP_GPS_POSN: 0xE9,
    WP_GPS_VELO: 0xEA,
    WP_GPS_PPS: 0xEB,
    WP_WR_TIME: 0xEC,
    WP_SYNC_TIME: 0xED,
};

// CPU Event names
const ECU_CPU_EVENT_NAMES = {
    0x0: 'RTI',
    0x1: 'IRQ',
    0x2: 'XIRQ',
    0x3: 'SWI',
    0x4: 'IOP',
    0x5: 'COP',
    0x6: 'CMF',
    0x7: 'RESET',
    0x8: 'OC5F',
    0x9: 'OC4F',
    0xA: 'OC3F',
    0xB: 'IC3'
};

// Error code names for EP_LOAD_ERR
const EP_LOAD_ERR_NAMES = {
    0x00: 'ERR_NOERR',
    0x01: 'ERR_NOTFOUND',
    0x02: 'ERR_NONAME',
    0x03: 'ERR_CKSUMERR',
    0x04: 'ERR_VERIFYERR',
    0x05: 'ERR_BADOFFSET',
};

// Binary display configuration
const BYTES_PER_LINE = 4;  // Number of bytes to display per line in binary mode

// ===== End: constants.js =====


/**
 * TimeKeeper - Manages 16-bit to 64-bit timestamp reconstruction
 *
 * Uses delta-based accumulation matching the Python decoder logic.
 * Each timestamp is a 16-bit value (0-65535). Timer wraps at 65536.
 * Each tick = 2 microseconds = 2000 nanoseconds.
 */
class TimeKeeper {
    constructor() {
        this.time_ns = 0n;           // Absolute time in nanoseconds
        this.prev_ts = -1;           // Previous 16-bit timestamp (-1 = first event)
        this.TIMER_MAX = 65536;      // 16-bit timer wraparound point
        this.TICKS_TO_NS = 2000n;    // Each tick = 2 microseconds = 2000 ns
    }

    /**
     * Process a timestamped event and advance time
     * @param {number} ts_16bit - Current 16-bit timestamp value
     */
    processTimestamp(ts_16bit) {
        if (this.prev_ts >= 0) {
            // Calculate delta from previous timestamp
            let delta_ticks = ts_16bit - this.prev_ts;

            // Handle wraparound: if delta is negative, timer wrapped
            // ECU guarantees timestamps are in non-decreasing order
            if (delta_ticks < 0) {
                delta_ticks += this.TIMER_MAX;
            }

            // Advance time by delta
            this.time_ns += BigInt(delta_ticks) * this.TICKS_TO_NS;
        }
        // else: first timestamp, time_ns stays at 0

        this.prev_ts = ts_16bit;
    }

    /**
     * Advance time by a fixed number of nanoseconds (for untimestamped events)
     * @param {number|bigint} delta_ns - Nanoseconds to advance
     */
    advanceByNs(delta_ns) {
        this.time_ns += BigInt(delta_ns);
    }

    /**
     * Get current time in seconds (floating point)
     * @returns {number} Current time in seconds
     */
    getTimeSec() {
        return Number(this.time_ns) / 1e9;
    }

    /**
     * Get current time in nanoseconds (bigint)
     * @returns {bigint} Current time in nanoseconds
     */
    getTimeNs() {
        return this.time_ns;
    }
}

/**
 * Parse binary log file into structured records
 * @param {Uint8Array} data - Binary log data
 * @returns {Object} Parsed log with records array and metadata
 */
function parseLog(data) {
    const timekeeper = new TimeKeeper();
    const records = [];  // Store records with binary data
    let recordCount = 0;
    let offset = 0;
    let byteOffset = 0;  // Track absolute byte position for binary display

    // State for EP_LOAD_NAME accumulation
    let epromNameBuffer = '';
    let epromNameBinaryData = [];
    let epromNameStartOffset = 0;

    const view = new DataView(data.buffer);

    // Helper functions
    function formatRecord(recordNum, tk) {
        const elapsed = tk.getTimeSec();
        return `[${recordNum.toString().padStart(6)}  @ ${elapsed.toFixed(4).padStart(10)}s]`;
    }

    function padEvent(name) {
        const targetLen = 12;
        if (name.length >= targetLen) return name;
        const padding = '&nbsp;'.repeat(targetLen - name.length);
        return name + padding;
    }

    // Track bytes read for current event
    let currentEventBytes = [];
    let currentEventStartOffset = 0;

    function startEvent() {
        currentEventBytes = [];
        currentEventStartOffset = byteOffset;
    }

    function readU8() {
        if (offset >= data.length) return null;
        const val = data[offset++];
        byteOffset++;
        currentEventBytes.push(val);
        return val;
    }

    function readU16LE() {
        if (offset + 1 >= data.length) return null;
        const val = view.getUint16(offset, true); // little-endian
        const b1 = data[offset];
        const b2 = data[offset + 1];
        offset += 2;
        byteOffset += 2;
        currentEventBytes.push(b1, b2);
        return val;
    }

    function readI16LE() {
        if (offset + 1 >= data.length) return null;
        const val = view.getInt16(offset, true); // little-endian
        const b1 = data[offset];
        const b2 = data[offset + 1];
        offset += 2;
        byteOffset += 2;
        currentEventBytes.push(b1, b2);
        return val;
    }

    function readBytes(n) {
        if (offset + n > data.length) return null;
        const bytes = data.slice(offset, offset + n);
        for (let i = 0; i < n; i++) {
            currentEventBytes.push(data[offset + i]);
        }
        offset += n;
        byteOffset += n;
        return bytes;
    }

    // Process all events - no limit
    const MAX_EVENTS = Infinity;

    while (offset < data.length && recordCount < MAX_EVENTS) {
        startEvent();
        const logid = readU8();
        if (logid === null) break;

        recordCount++;
        const prefix = formatRecord(recordCount, timekeeper);
        let line = '';
        let eventType = 'unknown';  // Track event type for graphing

        switch (logid) {
            // ===== GENERAL IDs =====
            case LOGID.GEN_ECU_LOG_VER:
                line = `${prefix}: <span class="event">${padEvent('ECU_VER')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'version';
                break;

            case LOGID.GEN_EP_LOG_VER:
                line = `${prefix}: <span class="event">${padEvent('EP_VER')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'version';
                break;

            case LOGID.GEN_WP_LOG_VER:
                line = `${prefix}: <span class="event">${padEvent('WP_VER')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'version';
                break;

            // ===== ECU IDs =====
            case LOGID.ECU_CPU_EVENT: {
                const evt = readU8();
                const evtName = ECU_CPU_EVENT_NAMES[evt] || `UNKNOWN(${evt})`;
                line = `${prefix}: <span class="event">${padEvent('CPU_EVT')}</span>: <span class="value">${evtName}</span>`;
                eventType = 'cpu_event';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_T1_OFLO: {
                const oflo_ts = readU16LE();
                timekeeper.processTimestamp(oflo_ts);
                line = `${prefix}: <span class="event">${padEvent('OFLO')}</span>: <span class="value">${oflo_ts}</span>`;
                eventType = 'timestamp';
                break;
            }

            case LOGID.ECU_L4000_EVENT:
                line = `${prefix}: <span class="event">${padEvent('L4000')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'timing';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.ECU_T1_HOFLO: {
                const hoflo_ts = readU16LE();
                timekeeper.processTimestamp(hoflo_ts);
                line = `${prefix}: <span class="event">${padEvent('HOFLO')}</span>: <span class="value">${hoflo_ts}</span>`;
                eventType = 'timestamp';
                break;
            }

            // Injector events
            case LOGID.ECU_F_INJ_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FI_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_INJ_DUR: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FI_DUR')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_INJ_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RI_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_INJ_DUR: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RI_DUR')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            // Coil events
            case LOGID.ECU_F_COIL_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_COIL_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_COIL_MAN_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_MAN_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_COIL_MAN_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_MAN_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_MAN_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_MAN_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_MAN_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_MAN_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            // Ignition delay
            case LOGID.ECU_F_IGN_DLY: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('F_IGN_DLY')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_IGN_DLY: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('R_IGN_DLY')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            // Other ECU events
            case LOGID.ECU_5MILLISEC_EVENT:
                readU8();  // Ignore garbage byte
                line = `${prefix}: <span class="event">5MS_EVENT</span>`;
                eventType = 'timing';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.ECU_CRANK_P6_MAX:
                readU8();  // Ignore garbage byte
                line = `${prefix}: <span class="event">CRANK_P6_MAX</span>`;
                eventType = 'crank';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.ECU_FUEL_PUMP: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('FUEL_PUMP')}</span>: <span class="value">${val ? 'ON' : 'OFF'}</span>`;
                eventType = 'fuel';
                timekeeper.advanceByNs(1);
                break;
            }

            // Error events
            case LOGID.ECU_ERROR_L000C:
            case LOGID.ECU_ERROR_L000D:
            case LOGID.ECU_ERROR_L000E:
            case LOGID.ECU_ERROR_L000F: {
                const val = readU8();
                const errName = ['ERR_L000C', 'ERR_L000D', 'ERR_L000E', 'ERR_L000F'][logid - LOGID.ECU_ERROR_L000C];
                line = `${prefix}: <span class="event">${padEvent(errName)}</span>: <span class="value">0x${val.toString(16).padStart(2, '0')}</span>`;
                eventType = 'error';
                timekeeper.advanceByNs(1);
                break;
            }

            // Sensor raw values
            case LOGID.ECU_RAW_VTA: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('VTA')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_MAP: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('MAP')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_AAP: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('AAP')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_THW: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('THW')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_THA: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('THA')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_VM: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('VM')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_PORTG_DB: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('PORTG_DB')}</span>: <span class="value">0b${val.toString(2).padStart(8, '0')}</span>`;
                eventType = 'debug';
                timekeeper.advanceByNs(1);
                break;
            }

            // Crankshaft events
            case LOGID.ECU_CRANKREF_START: {
                const cr_ts = readU16LE();
                timekeeper.processTimestamp(cr_ts);
                line = `${prefix}: <span class="event">${padEvent('CRANK_TS')}</span>: <span class="value">${cr_ts}</span>`;
                eventType = 'crank';
                break;
            }

            case LOGID.ECU_CRANKREF_ID: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('CRID')}</span>: <span class="value">${val}</span>`;
                eventType = 'crank';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_CAM_ERR: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('CAM_ERR')}</span>: <span class="value">${val}</span>`;
                eventType = 'crank';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_CAMSHAFT: {
                const cam_ts = readU16LE();
                timekeeper.processTimestamp(cam_ts);
                line = `${prefix}: <span class="event">${padEvent('CAM_TS')}</span>: <span class="value">${cam_ts}</span>`;
                eventType = 'crank';
                break;
            }

            // Spark events
            case LOGID.ECU_SPRK_X1: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('SPRK_X1')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_SPRK_X2: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('SPRK_X2')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_NOSPARK: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('NOSPARK')}</span>: <span class="value">0x${val.toString(16).padStart(2, '0')}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            // ===== EP Events =====
            case LOGID.EP_FIND_NAME:
            case LOGID.EP_LOAD_NAME: {
                const ch = readU8();

                if (epromNameBuffer === '') {
                    epromNameStartOffset = currentEventStartOffset;
                    epromNameBinaryData = [];
                }

                epromNameBinaryData.push(...currentEventBytes);

                if (ch === 0) {
                    if (logid == LOGID.EP_FIND_NAME) {
                        line = `${prefix}: <span class="event">${padEvent('FIND')}</span>: <span class="value">\"${epromNameBuffer}\"</span>`;
                    }
                    else {
                        line = `${prefix}: <span class="event">${padEvent('LOAD')}</span>: <span class="value">\"${epromNameBuffer}\"</span>`;
                    }

                    if (line) {
                        records.push({
                            html: line,
                            binData: epromNameBinaryData.slice(),
                            binOffset: epromNameStartOffset,
                            timestamp: timekeeper.getTimeSec(),
                            type: 'eprom',
                            logid: logid
                        });
                        recordCount++;
                        if (recordCount >= MAX_EVENTS) break;
                        line = '';
                    }

                    epromNameBuffer = '';
                    epromNameBinaryData = [];
                } else {
                    epromNameBuffer += String.fromCharCode(ch);
                    line = '';
                }
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.EP_LOAD_ADDR: {
                const addr = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('ADDR')}</span>: <span class="value">0x${addr.toString(16).padStart(4, '0')}</span>`;
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.EP_LOAD_LEN: {
                const len = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('LEN')}</span>: <span class="value">0x${len.toString(16).padStart(4, '0')}</span>`;
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.EP_LOAD_ERR: {
                const err = readU8();
                const errName = EP_LOAD_ERR_NAMES[err] || `UNKNOWN(${err})`;
                line = `${prefix}: <span class="event">${padEvent('STAT')}</span>: <span class="value">${errName}</span>`;
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            // ===== WP Events =====
            case LOGID.WP_CSECS:
            case LOGID.WP_SECS:
            case LOGID.WP_MINS:
            case LOGID.WP_HOURS:
            case LOGID.WP_DATE:
            case LOGID.WP_MONTH:
            case LOGID.WP_YEAR:
            case LOGID.WP_FIXTYPE: {
                const val = readU8();
                const names = {
                    [LOGID.WP_CSECS]: 'CSECS',
                    [LOGID.WP_SECS]: 'SECS',
                    [LOGID.WP_MINS]: 'MINS',
                    [LOGID.WP_HOURS]: 'HOURS',
                    [LOGID.WP_DATE]: 'DATE',
                    [LOGID.WP_MONTH]: 'MONTH',
                    [LOGID.WP_YEAR]: 'YEAR',
                    [LOGID.WP_FIXTYPE]: 'FIXTYPE'
                };
                line = `${prefix}: <span class="event">${padEvent(names[logid])}</span>: <span class="value">${val}</span>`;
                eventType = 'gps_time';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.WP_GPS_POSN: {
                const posBytes = readBytes(8);
                const lat = new DataView(posBytes.buffer).getInt32(0, true);
                const lon = new DataView(posBytes.buffer).getInt32(4, true);
                line = `${prefix}: <span class="event">${padEvent('GPS_POSN')}</span>: <span class="value">lat=${lat} lon=${lon}</span>`;
                eventType = 'gps';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.WP_GPS_VELO: {
                const vel = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('GPS_VELO')}</span>: <span class="value">${vel}</span>`;
                eventType = 'gps';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.WP_GPS_PPS:
                line = `${prefix}: <span class="event">GPS_PPS</span>`;
                eventType = 'gps';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.WP_SYNC_TIME: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('SYNC_TIME')}</span>: <span class="value">${val}</span>`;
                eventType = 'timing';
                timekeeper.advanceByNs(1);
                break;
            }

            default:
                line = `${prefix}: <span style="color: #ff6b6b;">UNKNOWN(0x${logid.toString(16).padStart(2, '0')})</span>`;
                eventType = 'unknown';
                timekeeper.advanceByNs(1);
                break;
        }

        if (line) {
            records.push({
                html: line,
                binData: currentEventBytes.slice(),
                binOffset: currentEventStartOffset,
                timestamp: timekeeper.getTimeSec(),
                type: eventType,
                logid: logid
            });
        }
    }

    return {
        records: records,
        recordCount: recordCount,
        duration: timekeeper.getTimeSec(),
        truncated: recordCount >= MAX_EVENTS
    };
}

// ===== End: js/parser.js =====

// ===== Bundled: js/textRenderer.js =====
// textRenderer.js - Text rendering with binary display support


/**
 * Render parsed records to HTML with optional binary display
 * @param {Object} parsedData - Parsed log data from parser.js
 * @param {boolean} showBinary - Whether to display binary data
 * @returns {string} HTML string
 */
function renderRecords(parsedData, showBinary) {
    const output = [];

    for (const record of parsedData.records) {
        if (showBinary && record.binData.length > 0) {
            // Format binary data with proper multi-line support
            const binLines = formatBinaryDataForRecord(record.binOffset, record.binData);
            const binLineArray = binLines.split('\n');

            // First line gets the record html appended
            output.push(`<div class="record">${binLineArray[0]} ${record.html}</div>`);

            // Additional lines (for multi-byte events) are standalone
            for (let i = 1; i < binLineArray.length; i++) {
                output.push(`<div class="record">${binLineArray[i]}</div>`);
            }
        } else {
            output.push(`<div class="record">${record.html}</div>`);
        }
    }

    return output.join('');
}

/**
 * Format binary data for a record with address and hex bytes
 * @param {number} startOffset - Starting byte offset
 * @param {Uint8Array} bytes - Binary data bytes
 * @returns {string} Formatted binary data lines
 */
function formatBinaryDataForRecord(startOffset, bytes) {
    const chunks = [];
    for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
        const chunk = bytes.slice(i, Math.min(i + BYTES_PER_LINE, bytes.length));
        const hexBytes = chunk.map(b => b.toString(16).padStart(2, '0').toUpperCase());

        // Pad with nbsp entities for alignment
        while (hexBytes.length < BYTES_PER_LINE) {
            hexBytes.push('&nbsp;&nbsp;');
        }

        const bytesStr = hexBytes.join(' ');
        const addr = (startOffset + i).toString(16).padStart(8, '0');
        chunks.push(`<span style="color: #569cd6;">0x${addr}: ${bytesStr}</span>`);
    }
    return chunks.join('\n');
}

// ===== End: js/textRenderer.js =====

// ===== Bundled: js/search.js =====
// search.js - Text search with highlighting

// Search state
let searchMatches = [];
let currentMatchIndex = -1;
let lastSearchTerm = '';

/**
 * Perform search through log records
 * @param {string} searchTerm - Search query
 */
function performSearch(searchTerm) {
    lastSearchTerm = searchTerm;
    searchMatches = [];
    currentMatchIndex = -1;

    const outputDiv = document.getElementById('textOutput');
    const records = outputDiv.querySelectorAll('.record');

    if (!searchTerm || searchTerm.length === 0) {
        // Clear all highlights
        records.forEach(record => {
            record.innerHTML = record.innerHTML
                .replace(/<mark class="search-highlight-current">(.+?)<\/mark>/g, '$1')
                .replace(/<mark class="search-highlight">(.+?)<\/mark>/g, '$1');
        });
        updateSearchUI();
        return;
    }

    // Search through all records (case-insensitive)
    const searchRegex = new RegExp(escapeRegExp(searchTerm), 'gi');

    records.forEach((record, index) => {
        const textContent = record.textContent || record.innerText;
        if (searchRegex.test(textContent)) {
            searchMatches.push(index);
        }
    });

    if (searchMatches.length > 0) {
        currentMatchIndex = 0;
        highlightMatches(searchTerm);
        scrollToCurrentMatch();
    }

    updateSearchUI();
}

/**
 * Navigate to next search match
 */
function searchNext() {
    if (searchMatches.length === 0) return;
    currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length;
    highlightMatches(lastSearchTerm);
    scrollToCurrentMatch();
    updateSearchUI();
}

/**
 * Navigate to previous search match
 */
function searchPrevious() {
    if (searchMatches.length === 0) return;
    currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
    highlightMatches(lastSearchTerm);
    scrollToCurrentMatch();
    updateSearchUI();
}

/**
 * Clear current search
 */
function clearSearch() {
    document.getElementById('searchInput').value = '';
    performSearch('');
}

/**
 * Get last search term (for re-applying after re-render)
 */
function getLastSearchTerm() {
    return lastSearchTerm;
}

// Private helper functions
function highlightMatches(searchTerm) {
    const outputDiv = document.getElementById('textOutput');
    const records = outputDiv.querySelectorAll('.record');

    records.forEach((record, index) => {
        // Remove existing highlights
        let html = record.innerHTML
            .replace(/<mark class="search-highlight-current">(.+?)<\/mark>/g, '$1')
            .replace(/<mark class="search-highlight">(.+?)<\/mark>/g, '$1');

        record.innerHTML = html;

        // Check if this record contains a match
        if (searchMatches.includes(index)) {
            const isCurrent = (index === searchMatches[currentMatchIndex]);
            highlightTextNodes(record, searchTerm, isCurrent);
        }
    });
}

function highlightTextNodes(element, searchTerm, isCurrent) {
    const highlightClass = isCurrent ? 'search-highlight-current' : 'search-highlight';
    const searchRegex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');

    const walker = document.createTreeWalker(
        element,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );

    const nodesToReplace = [];
    let node;

    // Collect all text nodes that contain matches
    while (node = walker.nextNode()) {
        if (searchRegex.test(node.textContent)) {
            nodesToReplace.push(node);
        }
    }

    // Replace text nodes with highlighted versions
    nodesToReplace.forEach(textNode => {
        const text = textNode.textContent;
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        const regex = new RegExp(escapeRegExp(searchTerm), 'gi');
        let match;

        while ((match = regex.exec(text)) !== null) {
            // Add text before match
            if (match.index > lastIndex) {
                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
            }

            // Add highlighted match
            const mark = document.createElement('mark');
            mark.className = highlightClass;
            mark.textContent = match[0];
            fragment.appendChild(mark);

            lastIndex = regex.lastIndex;
        }

        // Add remaining text
        if (lastIndex < text.length) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        }

        textNode.parentNode.replaceChild(fragment, textNode);
    });
}

function scrollToCurrentMatch() {
    if (currentMatchIndex >= 0 && currentMatchIndex < searchMatches.length) {
        const outputDiv = document.getElementById('textOutput');
        const records = outputDiv.querySelectorAll('.record');
        const currentRecord = records[searchMatches[currentMatchIndex]];

        if (currentRecord) {
            currentRecord.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
}

function updateSearchUI() {
    const hasResults = searchMatches.length > 0;
    const hasSearch = lastSearchTerm.length > 0;

    document.getElementById('searchPrevBtn').disabled = !hasResults;
    document.getElementById('searchNextBtn').disabled = !hasResults;
    document.getElementById('searchClearBtn').style.display = hasSearch ? 'block' : 'none';

    const countSpan = document.getElementById('searchCount');
    if (hasResults) {
        countSpan.textContent = `${currentMatchIndex + 1}/${searchMatches.length}`;
    } else if (hasSearch) {
        countSpan.textContent = 'No matches';
    } else {
        countSpan.textContent = '';
    }
}

function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// ===== End: js/search.js =====

// ===== Bundled: js/fileManager.js =====
// fileManager.js - File I/O and recent files management

const MAX_RECENT_FILES = 10;

/**
 * Get recent files from localStorage
 * @returns {Array} Array of recent file objects
 */
function getRecentFiles() {
    const stored = localStorage.getItem('recentFiles');
    return stored ? JSON.parse(stored) : [];
}

/**
 * Save recent file to localStorage
 * @param {Object} fileInfo - File information {name, size, timestamp}
 */
function saveRecentFile(fileInfo) {
    let recent = getRecentFiles();

    // Remove if already exists
    recent = recent.filter(f => f.name !== fileInfo.name);

    // Add to front
    recent.unshift(fileInfo);

    // Keep only MAX_RECENT_FILES
    if (recent.length > MAX_RECENT_FILES) {
        recent = recent.slice(0, MAX_RECENT_FILES);
    }

    localStorage.setItem('recentFiles', JSON.stringify(recent));
}

/**
 * Clear all recent files
 */
function clearRecentFiles() {
    localStorage.removeItem('recentFiles');
}

/**
 * Read file as Uint8Array
 * @param {File} file - File object from input
 * @returns {Promise<Uint8Array>} File data
 */
function readFileAsUint8Array(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
            resolve(new Uint8Array(e.target.result));
        };

        reader.onerror = (e) => {
            reject(new Error('Failed to read file'));
        };

        reader.readAsArrayBuffer(file);
    });
}

/**
 * Format bytes to human-readable string
 * @param {number} bytes - Number of bytes
 * @returns {string} Formatted string (e.g., "1.5 MB")
 */
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}

// ===== End: js/fileManager.js =====


        // Global state
        let showBinaryData = true;
        let currentParsedData = null;

        // Make functions globally accessible for onclick handlers
        window.handleFile = handleFile;
        window.toggleRecentFiles = toggleRecentFiles;
        window.clearLog = clearLog;
        window.switchTab = switchTab;
        window.handleBinaryDisplayToggle = handleBinaryDisplayToggle;
        window.handleSearchKeyup = handleSearchKeyup;
        window.handleSearchNext = () => searchNext();
        window.handleSearchPrevious = () => searchPrevious();
        window.handleClearSearch = () => clearSearch();

        // File handling
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            console.log('handleFile called with:', file.name, file.size);
            const startTime = performance.now();

            // Show progress overlay
            const overlay = document.getElementById('progressOverlay');
            const progressText = document.getElementById('progressText');
            const progressBar = document.getElementById('progressBar');
            const progressStatus = document.getElementById('progressStatus');

            overlay.style.display = 'flex';
            progressText.textContent = 'Reading file...';
            progressBar.style.width = '10%';
            progressStatus.textContent = '10%';

            try {
                console.log('Reading file as Uint8Array...');
                const data = await readFileAsUint8Array(file);
                console.log('File read complete:', data.length, 'bytes');

                progressText.textContent = 'Parsing log data...';
                progressBar.style.width = '30%';
                progressStatus.textContent = '30%';

                // Allow UI to update
                await new Promise(resolve => setTimeout(resolve, 50));

                console.log('Parsing log...');
                const result = parseLog(data);
                console.log('Parse complete:', result.recordCount, 'events');
                const processingTime = (performance.now() - startTime) / 1000;

                progressText.textContent = 'Rendering output...';
                progressBar.style.width = '60%';
                progressStatus.textContent = '60%';

                // Store parsed data
                currentParsedData = result;

                // Save to recent files
                saveRecentFile({
                    name: file.name,
                    size: data.length,
                    timestamp: Date.now()
                });

                // Update stats
                document.getElementById('statFileSize').textContent = formatBytes(data.length);
                document.getElementById('statEvents').textContent = result.recordCount.toLocaleString();
                document.getElementById('statDuration').textContent = result.duration.toFixed(2) + 's';
                document.getElementById('statProcessTime').textContent = processingTime.toFixed(2) + 's';

                progressBar.style.width = '80%';
                progressStatus.textContent = '80%';

                // Render output
                console.log('Rendering records...');
                let html = renderRecords(result, showBinaryData);
                if (result.truncated) {
                    html += `<div style="color: #ffa500; margin-top: 20px; text-align: center;">‚ö†Ô∏è Output limited to ${result.recordCount.toLocaleString()} events for performance</div>`;
                }
                document.getElementById('textOutput').innerHTML = html;
                console.log('Rendering complete');

                progressBar.style.width = '100%';
                progressStatus.textContent = '100%';

                // Update UI
                document.getElementById('dropZone').style.display = 'none';
                document.getElementById('tabsContainer').style.display = 'flex';
                document.getElementById('clearBtn').disabled = false;
                document.getElementById('fileInfo').textContent = `${file.name} (${formatBytes(data.length)})`;

                console.log('All done!');

                // Hide progress after a short delay
                setTimeout(() => {
                    overlay.style.display = 'none';
                    progressBar.style.width = '0%';
                }, 500);

            } catch (err) {
                console.error('Error parsing log:', err);
                console.error('Stack trace:', err.stack);
                overlay.style.display = 'none';
                document.getElementById('textOutput').innerHTML = `<div class="error">Error parsing log: ${err.message}<br><br>Check browser console for details.</div>`;
                document.getElementById('dropZone').style.display = 'none';
                document.getElementById('tabsContainer').style.display = 'flex';
            }
        }

        function handleBinaryDisplayToggle() {
            showBinaryData = document.getElementById('showBinaryCheckbox').checked;

            if (currentParsedData) {
                let html = renderRecords(currentParsedData, showBinaryData);

                if (currentParsedData.truncated) {
                    html += `<div style="color: #ffa500; margin-top: 20px; text-align: center;">‚ö†Ô∏è Output limited to ${currentParsedData.recordCount.toLocaleString()} events for performance</div>`;
                }

                document.getElementById('textOutput').innerHTML = html;

                // Re-apply search if active
                const lastTerm = getLastSearchTerm();
                if (lastTerm) {
                    performSearch(lastTerm);
                }
            }
        }

        function handleSearchKeyup(event) {
            if (event.key === 'Enter') {
                if (event.shiftKey) {
                    searchPrevious();
                } else {
                    searchNext();
                }
            } else {
                const searchTerm = document.getElementById('searchInput').value;
                performSearch(searchTerm);
            }
        }

        function toggleRecentFiles() {
            const panel = document.getElementById('recentFilesPanel');
            const isVisible = panel.style.display !== 'none';

            if (isVisible) {
                panel.style.display = 'none';
            } else {
                panel.style.display = 'block';
                renderRecentFiles();
            }
        }

        function renderRecentFiles() {
            const recent = getRecentFiles();
            const listDiv = document.getElementById('recentFilesList');

            if (recent.length === 0) {
                listDiv.innerHTML = '<p style="color: #666;">No recent files</p>';
                return;
            }

            listDiv.innerHTML = recent.map(f => `
                <div style="padding: 10px; margin-bottom: 10px; background: white; border-radius: 5px; cursor: pointer;"
                     onclick="alert('Recent file selection not yet implemented')">
                    <strong>${f.name}</strong>
                    <div style="font-size: 12px; color: #666;">
                        ${formatBytes(f.size)} ‚Ä¢ ${new Date(f.timestamp).toLocaleString()}
                    </div>
                </div>
            `).join('');
        }

        function clearLog() {
            document.getElementById('dropZone').style.display = 'block';
            document.getElementById('tabsContainer').style.display = 'none';
            document.getElementById('fileInfo').textContent = '';
            document.getElementById('textOutput').innerHTML = '<div style="color: #6c757d; text-align: center; padding: 40px;">No log file loaded</div>';
            document.getElementById('clearBtn').disabled = true;
            document.getElementById('fileInput').value = '';
            currentParsedData = null;
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.dataset.tab === tabName);
            });
        }

        // Drag and drop
        document.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });
    
    </script>
</body>
</html>
