<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèçÔ∏è umod4 Log Viewer - v2.1 Bundled (for phones/tablets)</title>
    <!-- Version 2.1 - Bundled with virtual scrolling -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            padding: 20px;
            overflow: hidden;
            min-height: 0;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .file-input {
            display: none;
        }

        .search-container {
            display: flex;
            align-items: center;
            background: white;
            border-radius: 8px;
            padding: 8px 12px;
            gap: 8px;
            flex: 1;
            max-width: 400px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .search-input {
            flex: 1;
            border: none;
            outline: none;
            font-size: 14px;
            padding: 4px;
        }

        .search-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .search-btn:hover:not(:disabled) {
            background: #e9ecef;
        }

        .search-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .search-count {
            color: #6c757d;
            font-size: 12px;
            min-width: 60px;
            text-align: center;
        }

        .drop-zone {
            background: white;
            border: 3px dashed #cbd5e0;
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }

        .drop-zone:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .drop-zone-content h2 {
            color: #2d3748;
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #2d3748;
        }

        .tabs-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            flex: 1;
            display: none;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .tabs {
            display: flex;
            background: #2d2d2d;
            border-bottom: 2px solid #495057;
        }

        .tab {
            padding: 12px 24px;
            cursor: pointer;
            background: #2d2d2d;
            color: #aaa;
            border: none;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .tab:hover {
            background: #3d3d3d;
            color: #fff;
        }

        .tab.active {
            background: #1e1e1e;
            color: #667eea;
            border-bottom: 2px solid #667eea;
        }

        .tab-content {
            display: none;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
        }

        #textOutput {
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.6;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow-y: auto;
            height: 100%;
        }

        .record {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-all;
            color: #d4d4d4;
        }

        .event {
            color: #4ec9b0;
        }

        .value {
            color: #ce9178;
        }

        .graph-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #6c757d;
            text-align: center;
        }

        .error {
            color: #f48771;
            padding: 20px;
            background: #f8d7da;
        }

        .progress-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .progress-box {
            background: #2d2d2d;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            min-width: 300px;
            text-align: center;
        }

        .progress-text {
            color: #fff;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #1e1e1e;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-status {
            color: #aaa;
            font-size: 12px;
            margin-top: 10px;
        }

        mark.search-highlight {
            background: #ffd700;
            color: #000;
        }

        mark.search-highlight-current {
            background: #ff6b35;
            color: #fff;
        }
    </style>
</head>
<body>
    <!-- Progress overlay -->
    <div id="progressOverlay" class="progress-overlay">
        <div class="progress-box">
            <div class="progress-text" id="progressText">Loading file...</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-status" id="progressStatus">0%</div>
        </div>
    </div>
    <div class="container">
        <div class="header">
            <h1>üèçÔ∏è umod4 Log Viewer</h1>
            <p>Motorcycle Data Logger Visualization Tool - v2.1 Bundled (for phones/tablets)</p>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
                üìÅ Open Log File
            </button>
            <input type="file" id="fileInput" class="file-input">

            <button class="btn btn-secondary" id="recentBtn" onclick="toggleRecentFiles()">
                üïí Recent Files
            </button>

            <button class="btn btn-secondary" id="clearBtn" onclick="clearLog()" disabled>
                üóëÔ∏è Clear
            </button>

            <div class="search-container">
                <span style="color: #6c757d;">üîç</span>
                <input type="text" id="searchInput" class="search-input" placeholder="Search..." onkeyup="handleSearchKeyup(event)">
                <button class="search-btn" id="searchPrevBtn" onclick="handleSearchPrevious()" title="Previous (Shift+Enter)" disabled>‚ñ≤</button>
                <button class="search-btn" id="searchNextBtn" onclick="handleSearchNext()" title="Next (Enter)" disabled>‚ñº</button>
                <span id="searchCount" class="search-count"></span>
                <button class="search-btn" id="searchClearBtn" onclick="handleClearSearch()" title="Clear search" style="display: none;">‚úï</button>
            </div>

            <span id="fileInfo" style="margin-left: auto; color: #6c757d;"></span>
        </div>

        <div id="recentFilesPanel" style="display: none; padding: 20px; background: #f8f9fa; border-bottom: 1px solid #dee2e6;">
            <h3 style="margin-bottom: 15px; font-size: 16px;">Recent Files</h3>
            <div id="recentFilesList"></div>
        </div>

        <div id="dropZone" class="drop-zone">
            <div class="drop-zone-content">
                <h2>Drop log file here</h2>
                <p style="color: #aaa;">or click "Open Log File" button above</p>
                <p style="color: #666; margin-top: 20px; font-size: 12px;">Supports binary .log files from umod4 logger</p>
            </div>
        </div>

        <div id="tabsContainer" class="tabs-container">
            <div class="tabs">
                <button class="tab active" data-tab="text" onclick="switchTab('text')">üìÑ Text View</button>
                <button class="tab" data-tab="graph" onclick="switchTab('graph')">üìä Graph View</button>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-label">File Size</div>
                    <div class="stat-value" id="statFileSize">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Total Events</div>
                    <div class="stat-value" id="statEvents">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Duration</div>
                    <div class="stat-value" id="statDuration">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Processing Time</div>
                    <div class="stat-value" id="statProcessTime">-</div>
                </div>
            </div>

            <div class="tab-content active" id="textTab" data-tab="text">
                <div id="textOutput"></div>
            </div>

            <div class="tab-content" id="graphTab" data-tab="graph">
                <div class="graph-placeholder">
                    <div>
                        <h3>Graph View - Coming Soon</h3>
                        <p>Interactive time-series visualization will be added in the next version</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>

        // Import modules
// ===== Bundled: js/parser.js =====
// parser.js - Binary log parsing and timestamp reconstruction

// ===== Bundled: constants.js =====
// constants.js - LOGID definitions and lookup tables
// Exported from ECU_log.h, EP_log.h, WP_log.h, log_base.h

const LOGID = {
    // Base addresses
    GEN_BASE: 0x00,
    ECU_BASE: 0x10,
    EP_BASE: 0xD0,
    WP_BASE: 0xE0,

    // General IDs
    GEN_ECU_LOG_VER: 0x01,
    GEN_EP_LOG_VER: 0x02,
    GEN_WP_LOG_VER: 0x03,

    // ECU IDs (complete list from ECU_log.h)
    ECU_CPU_EVENT: 0x10,
    ECU_T1_OFLO: 0x12,
    ECU_L4000_EVENT: 0x18,
    ECU_T1_HOFLO: 0x1E,
    ECU_F_INJ_ON: 0x20,
    ECU_F_INJ_DUR: 0x22,
    ECU_R_INJ_ON: 0x24,
    ECU_R_INJ_DUR: 0x26,
    ECU_F_COIL_ON: 0x30,
    ECU_F_COIL_OFF: 0x32,
    ECU_R_COIL_ON: 0x34,
    ECU_R_COIL_OFF: 0x36,
    ECU_F_COIL_MAN_ON: 0x38,
    ECU_F_COIL_MAN_OFF: 0x3A,
    ECU_R_COIL_MAN_ON: 0x3C,
    ECU_R_COIL_MAN_OFF: 0x3E,
    ECU_F_IGN_DLY: 0x40,
    ECU_R_IGN_DLY: 0x42,
    ECU_5MILLISEC_EVENT: 0x48,
    ECU_CRANK_P6_MAX: 0x49,
    ECU_FUEL_PUMP: 0x4A,
    ECU_ERROR_L000C: 0x50,
    ECU_ERROR_L000D: 0x51,
    ECU_ERROR_L000E: 0x52,
    ECU_ERROR_L000F: 0x53,
    ECU_RAW_VTA: 0x60,
    ECU_RAW_MAP: 0x62,
    ECU_RAW_AAP: 0x63,
    ECU_RAW_THW: 0x64,
    ECU_RAW_THA: 0x65,
    ECU_RAW_VM: 0x66,
    ECU_PORTG_DB: 0x67,
    ECU_CRANKREF_START: 0x70,
    ECU_CRANKREF_ID: 0x72,
    ECU_CAM_ERR: 0x73,
    ECU_CAMSHAFT: 0x74,
    ECU_SPRK_X1: 0x80,
    ECU_SPRK_X2: 0x82,
    ECU_NOSPARK: 0x84,

    // EP IDs
    EP_LOAD_NAME: 0xD0,
    EP_FIND_NAME: 0xD1,
    EP_LOAD_ADDR: 0xD2,
    EP_LOAD_LEN: 0xD4,
    EP_LOAD_ERR: 0xD6,

    // WP IDs (complete list from WP_log.h)
    WP_CSECS: 0xE1,
    WP_SECS: 0xE2,
    WP_MINS: 0xE3,
    WP_HOURS: 0xE4,
    WP_DATE: 0xE5,
    WP_MONTH: 0xE6,
    WP_YEAR: 0xE7,
    WP_FIXTYPE: 0xE8,
    WP_GPS_POSN: 0xE9,
    WP_GPS_VELO: 0xEA,
    WP_GPS_PPS: 0xEB,
    WP_WR_TIME: 0xEC,
    WP_SYNC_TIME: 0xED,
};

// CPU Event names
const ECU_CPU_EVENT_NAMES = {
    0x0: 'RTI',
    0x1: 'IRQ',
    0x2: 'XIRQ',
    0x3: 'SWI',
    0x4: 'IOP',
    0x5: 'COP',
    0x6: 'CMF',
    0x7: 'RESET',
    0x8: 'OC5F',
    0x9: 'OC4F',
    0xA: 'OC3F',
    0xB: 'IC3'
};

// Error code names for EP_LOAD_ERR
const EP_LOAD_ERR_NAMES = {
    0x00: 'ERR_NOERR',
    0x01: 'ERR_NOTFOUND',
    0x02: 'ERR_NONAME',
    0x03: 'ERR_CKSUMERR',
    0x04: 'ERR_VERIFYERR',
    0x05: 'ERR_BADOFFSET',
};

// Binary display configuration
const BYTES_PER_LINE = 4;  // Number of bytes to display per line in binary mode

// ===== End: constants.js =====


/**
 * TimeKeeper - Manages 16-bit to 64-bit timestamp reconstruction
 *
 * Uses delta-based accumulation matching the Python decoder logic.
 * Each timestamp is a 16-bit value (0-65535). Timer wraps at 65536.
 * Each tick = 2 microseconds = 2000 nanoseconds.
 */
class TimeKeeper {
    constructor() {
        this.time_ns = 0n;           // Absolute time in nanoseconds
        this.prev_ts = -1;           // Previous 16-bit timestamp (-1 = first event)
        this.TIMER_MAX = 65536;      // 16-bit timer wraparound point
        this.TICKS_TO_NS = 2000n;    // Each tick = 2 microseconds = 2000 ns
    }

    /**
     * Process a timestamped event and advance time
     * @param {number} ts_16bit - Current 16-bit timestamp value
     */
    processTimestamp(ts_16bit) {
        if (this.prev_ts >= 0) {
            // Calculate delta from previous timestamp
            let delta_ticks = ts_16bit - this.prev_ts;

            // Handle wraparound: if delta is negative, timer wrapped
            // ECU guarantees timestamps are in non-decreasing order
            if (delta_ticks < 0) {
                delta_ticks += this.TIMER_MAX;
            }

            // Advance time by delta
            this.time_ns += BigInt(delta_ticks) * this.TICKS_TO_NS;
        }
        // else: first timestamp, time_ns stays at 0

        this.prev_ts = ts_16bit;
    }

    /**
     * Advance time by a fixed number of nanoseconds (for untimestamped events)
     * @param {number|bigint} delta_ns - Nanoseconds to advance
     */
    advanceByNs(delta_ns) {
        this.time_ns += BigInt(delta_ns);
    }

    /**
     * Get current time in seconds (floating point)
     * @returns {number} Current time in seconds
     */
    getTimeSec() {
        return Number(this.time_ns) / 1e9;
    }

    /**
     * Get current time in nanoseconds (bigint)
     * @returns {bigint} Current time in nanoseconds
     */
    getTimeNs() {
        return this.time_ns;
    }
}

/**
 * Parse binary log file into structured records
 * @param {Uint8Array} data - Binary log data
 * @returns {Object} Parsed log with records array and metadata
 */
function parseLog(data) {
    const timekeeper = new TimeKeeper();
    const records = [];  // Store records with binary data
    let recordCount = 0;
    let offset = 0;
    let byteOffset = 0;  // Track absolute byte position for binary display

    // State for EP_LOAD_NAME accumulation
    let epromNameBuffer = '';
    let epromNameBinaryData = [];
    let epromNameStartOffset = 0;

    const view = new DataView(data.buffer);

    // Helper functions
    function formatRecord(recordNum, tk) {
        const elapsed = tk.getTimeSec();
        return `[${recordNum.toString().padStart(6)}  @ ${elapsed.toFixed(4).padStart(10)}s]`;
    }

    function padEvent(name) {
        const targetLen = 12;
        if (name.length >= targetLen) return name;
        const padding = '&nbsp;'.repeat(targetLen - name.length);
        return name + padding;
    }

    // Track bytes read for current event
    let currentEventBytes = [];
    let currentEventStartOffset = 0;

    function startEvent() {
        currentEventBytes = [];
        currentEventStartOffset = byteOffset;
    }

    function readU8() {
        if (offset >= data.length) return null;
        const val = data[offset++];
        byteOffset++;
        currentEventBytes.push(val);
        return val;
    }

    function readU16LE() {
        if (offset + 1 >= data.length) return null;
        const val = view.getUint16(offset, true); // little-endian
        const b1 = data[offset];
        const b2 = data[offset + 1];
        offset += 2;
        byteOffset += 2;
        currentEventBytes.push(b1, b2);
        return val;
    }

    function readI16LE() {
        if (offset + 1 >= data.length) return null;
        const val = view.getInt16(offset, true); // little-endian
        const b1 = data[offset];
        const b2 = data[offset + 1];
        offset += 2;
        byteOffset += 2;
        currentEventBytes.push(b1, b2);
        return val;
    }

    function readBytes(n) {
        if (offset + n > data.length) return null;
        const bytes = data.slice(offset, offset + n);
        for (let i = 0; i < n; i++) {
            currentEventBytes.push(data[offset + i]);
        }
        offset += n;
        byteOffset += n;
        return bytes;
    }

    // Process all events - no limit
    const MAX_EVENTS = Infinity;

    while (offset < data.length && recordCount < MAX_EVENTS) {
        startEvent();
        const logid = readU8();
        if (logid === null) break;

        recordCount++;
        const prefix = formatRecord(recordCount, timekeeper);
        let line = '';
        let eventType = 'unknown';  // Track event type for graphing

        switch (logid) {
            // ===== GENERAL IDs =====
            case LOGID.GEN_ECU_LOG_VER:
                line = `${prefix}: <span class="event">${padEvent('ECU_VER')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'version';
                break;

            case LOGID.GEN_EP_LOG_VER:
                line = `${prefix}: <span class="event">${padEvent('EP_VER')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'version';
                break;

            case LOGID.GEN_WP_LOG_VER:
                line = `${prefix}: <span class="event">${padEvent('WP_VER')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'version';
                break;

            // ===== ECU IDs =====
            case LOGID.ECU_CPU_EVENT: {
                const evt = readU8();
                const evtName = ECU_CPU_EVENT_NAMES[evt] || `UNKNOWN(${evt})`;
                line = `${prefix}: <span class="event">${padEvent('CPU_EVT')}</span>: <span class="value">${evtName}</span>`;
                eventType = 'cpu_event';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_T1_OFLO: {
                const oflo_ts = readU16LE();
                timekeeper.processTimestamp(oflo_ts);
                line = `${prefix}: <span class="event">${padEvent('OFLO')}</span>: <span class="value">${oflo_ts}</span>`;
                eventType = 'timestamp';
                break;
            }

            case LOGID.ECU_L4000_EVENT:
                line = `${prefix}: <span class="event">${padEvent('L4000')}</span>: <span class="value">${readU8()}</span>`;
                eventType = 'timing';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.ECU_T1_HOFLO: {
                const hoflo_ts = readU16LE();
                timekeeper.processTimestamp(hoflo_ts);
                line = `${prefix}: <span class="event">${padEvent('HOFLO')}</span>: <span class="value">${hoflo_ts}</span>`;
                eventType = 'timestamp';
                break;
            }

            // Injector events
            case LOGID.ECU_F_INJ_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FI_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_INJ_DUR: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FI_DUR')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_INJ_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RI_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_INJ_DUR: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RI_DUR')}</span>: <span class="value">${val}</span>`;
                eventType = 'injector';
                timekeeper.advanceByNs(1);
                break;
            }

            // Coil events
            case LOGID.ECU_F_COIL_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_COIL_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_COIL_MAN_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_MAN_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_F_COIL_MAN_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('FC_MAN_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_MAN_ON: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_MAN_ON')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_COIL_MAN_OFF: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('RC_MAN_OFF')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            // Ignition delay
            case LOGID.ECU_F_IGN_DLY: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('F_IGN_DLY')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_R_IGN_DLY: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('R_IGN_DLY')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            // Other ECU events
            case LOGID.ECU_5MILLISEC_EVENT:
                readU8();  // Ignore garbage byte
                line = `${prefix}: <span class="event">5MS_EVENT</span>`;
                eventType = 'timing';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.ECU_CRANK_P6_MAX:
                readU8();  // Ignore garbage byte
                line = `${prefix}: <span class="event">CRANK_P6_MAX</span>`;
                eventType = 'crank';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.ECU_FUEL_PUMP: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('FUEL_PUMP')}</span>: <span class="value">${val ? 'ON' : 'OFF'}</span>`;
                eventType = 'fuel';
                timekeeper.advanceByNs(1);
                break;
            }

            // Error events
            case LOGID.ECU_ERROR_L000C:
            case LOGID.ECU_ERROR_L000D:
            case LOGID.ECU_ERROR_L000E:
            case LOGID.ECU_ERROR_L000F: {
                const val = readU8();
                const errName = ['ERR_L000C', 'ERR_L000D', 'ERR_L000E', 'ERR_L000F'][logid - LOGID.ECU_ERROR_L000C];
                line = `${prefix}: <span class="event">${padEvent(errName)}</span>: <span class="value">0x${val.toString(16).padStart(2, '0')}</span>`;
                eventType = 'error';
                timekeeper.advanceByNs(1);
                break;
            }

            // Sensor raw values
            case LOGID.ECU_RAW_VTA: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('VTA')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_MAP: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('MAP')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_AAP: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('AAP')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_THW: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('THW')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_THA: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('THA')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_RAW_VM: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('VM')}</span>: <span class="value">${val}</span>`;
                eventType = 'sensor';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_PORTG_DB: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('PORTG_DB')}</span>: <span class="value">0b${val.toString(2).padStart(8, '0')}</span>`;
                eventType = 'debug';
                timekeeper.advanceByNs(1);
                break;
            }

            // Crankshaft events
            case LOGID.ECU_CRANKREF_START: {
                const cr_ts = readU16LE();
                timekeeper.processTimestamp(cr_ts);
                line = `${prefix}: <span class="event">${padEvent('CRANK_TS')}</span>: <span class="value">${cr_ts}</span>`;
                eventType = 'crank';
                break;
            }

            case LOGID.ECU_CRANKREF_ID: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('CRID')}</span>: <span class="value">${val}</span>`;
                eventType = 'crank';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_CAM_ERR: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('CAM_ERR')}</span>: <span class="value">${val}</span>`;
                eventType = 'crank';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_CAMSHAFT: {
                const cam_ts = readU16LE();
                timekeeper.processTimestamp(cam_ts);
                line = `${prefix}: <span class="event">${padEvent('CAM_TS')}</span>: <span class="value">${cam_ts}</span>`;
                eventType = 'crank';
                break;
            }

            // Spark events
            case LOGID.ECU_SPRK_X1: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('SPRK_X1')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_SPRK_X2: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('SPRK_X2')}</span>: <span class="value">${val}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.ECU_NOSPARK: {
                const val = readU8();
                line = `${prefix}: <span class="event">${padEvent('NOSPARK')}</span>: <span class="value">0x${val.toString(16).padStart(2, '0')}</span>`;
                eventType = 'ignition';
                timekeeper.advanceByNs(1);
                break;
            }

            // ===== EP Events =====
            case LOGID.EP_FIND_NAME:
            case LOGID.EP_LOAD_NAME: {
                const ch = readU8();

                if (epromNameBuffer === '') {
                    epromNameStartOffset = currentEventStartOffset;
                    epromNameBinaryData = [];
                }

                epromNameBinaryData.push(...currentEventBytes);

                if (ch === 0) {
                    if (logid == LOGID.EP_FIND_NAME) {
                        line = `${prefix}: <span class="event">${padEvent('FIND')}</span>: <span class="value">\"${epromNameBuffer}\"</span>`;
                    }
                    else {
                        line = `${prefix}: <span class="event">${padEvent('LOAD')}</span>: <span class="value">\"${epromNameBuffer}\"</span>`;
                    }

                    if (line) {
                        records.push({
                            html: line,
                            binData: epromNameBinaryData.slice(),
                            binOffset: epromNameStartOffset,
                            timestamp: timekeeper.getTimeSec(),
                            type: 'eprom',
                            logid: logid
                        });
                        recordCount++;
                        if (recordCount >= MAX_EVENTS) break;
                        line = '';
                    }

                    epromNameBuffer = '';
                    epromNameBinaryData = [];
                } else {
                    epromNameBuffer += String.fromCharCode(ch);
                    line = '';
                }
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.EP_LOAD_ADDR: {
                const addr = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('ADDR')}</span>: <span class="value">0x${addr.toString(16).padStart(4, '0')}</span>`;
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.EP_LOAD_LEN: {
                const len = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('LEN')}</span>: <span class="value">0x${len.toString(16).padStart(4, '0')}</span>`;
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.EP_LOAD_ERR: {
                const err = readU8();
                const errName = EP_LOAD_ERR_NAMES[err] || `UNKNOWN(${err})`;
                line = `${prefix}: <span class="event">${padEvent('STAT')}</span>: <span class="value">${errName}</span>`;
                eventType = 'eprom';
                timekeeper.advanceByNs(1);
                break;
            }

            // ===== WP Events =====
            case LOGID.WP_CSECS:
            case LOGID.WP_SECS:
            case LOGID.WP_MINS:
            case LOGID.WP_HOURS:
            case LOGID.WP_DATE:
            case LOGID.WP_MONTH:
            case LOGID.WP_YEAR:
            case LOGID.WP_FIXTYPE: {
                const val = readU8();
                const names = {
                    [LOGID.WP_CSECS]: 'CSECS',
                    [LOGID.WP_SECS]: 'SECS',
                    [LOGID.WP_MINS]: 'MINS',
                    [LOGID.WP_HOURS]: 'HOURS',
                    [LOGID.WP_DATE]: 'DATE',
                    [LOGID.WP_MONTH]: 'MONTH',
                    [LOGID.WP_YEAR]: 'YEAR',
                    [LOGID.WP_FIXTYPE]: 'FIXTYPE'
                };
                line = `${prefix}: <span class="event">${padEvent(names[logid])}</span>: <span class="value">${val}</span>`;
                eventType = 'gps_time';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.WP_GPS_POSN: {
                const posBytes = readBytes(8);
                const lat = new DataView(posBytes.buffer).getInt32(0, true);
                const lon = new DataView(posBytes.buffer).getInt32(4, true);
                line = `${prefix}: <span class="event">${padEvent('GPS_POSN')}</span>: <span class="value">lat=${lat} lon=${lon}</span>`;
                eventType = 'gps';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.WP_GPS_VELO: {
                const vel = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('GPS_VELO')}</span>: <span class="value">${vel}</span>`;
                eventType = 'gps';
                timekeeper.advanceByNs(1);
                break;
            }

            case LOGID.WP_GPS_PPS:
                line = `${prefix}: <span class="event">GPS_PPS</span>`;
                eventType = 'gps';
                timekeeper.advanceByNs(1);
                break;

            case LOGID.WP_SYNC_TIME: {
                const val = readU16LE();
                line = `${prefix}: <span class="event">${padEvent('SYNC_TIME')}</span>: <span class="value">${val}</span>`;
                eventType = 'timing';
                timekeeper.advanceByNs(1);
                break;
            }

            default:
                line = `${prefix}: <span style="color: #ff6b6b;">UNKNOWN(0x${logid.toString(16).padStart(2, '0')})</span>`;
                eventType = 'unknown';
                timekeeper.advanceByNs(1);
                break;
        }

        if (line) {
            records.push({
                html: line,
                binData: currentEventBytes.slice(),
                binOffset: currentEventStartOffset,
                timestamp: timekeeper.getTimeSec(),
                type: eventType,
                logid: logid
            });
        }
    }

    return {
        records: records,
        recordCount: recordCount,
        duration: timekeeper.getTimeSec(),
        truncated: recordCount >= MAX_EVENTS
    };
}

// ===== End: js/parser.js =====

// ===== Bundled: js/virtualRenderer.js =====
// virtualRenderer.js - Virtual scrolling renderer for large log files

// ===== Bundled: textRenderer.js =====
// textRenderer.js - Text rendering with binary display support


/**
 * Render parsed records to HTML with optional binary display
 * @param {Object} parsedData - Parsed log data from parser.js
 * @param {boolean} showBinary - Whether to display binary data
 * @returns {string} HTML string
 */
function renderRecords(parsedData, showBinary) {
    const output = [];

    for (const record of parsedData.records) {
        if (showBinary && record.binData.length > 0) {
            // Format binary data with proper multi-line support
            const binLines = formatBinaryDataForRecord(record.binOffset, record.binData);
            const binLineArray = binLines.split('\n');

            // First line gets the record html appended
            output.push(`<div class="record">${binLineArray[0]} ${record.html}</div>`);

            // Additional lines (for multi-byte events) are standalone
            for (let i = 1; i < binLineArray.length; i++) {
                output.push(`<div class="record">${binLineArray[i]}</div>`);
            }
        } else {
            output.push(`<div class="record">${record.html}</div>`);
        }
    }

    return output.join('');
}

/**
 * Format binary data for a record with address and hex bytes
 * @param {number} startOffset - Starting byte offset
 * @param {Uint8Array} bytes - Binary data bytes
 * @returns {string} Formatted binary data lines
 */
function formatBinaryDataForRecord(startOffset, bytes) {
    const chunks = [];
    for (let i = 0; i < bytes.length; i += BYTES_PER_LINE) {
        const chunk = bytes.slice(i, Math.min(i + BYTES_PER_LINE, bytes.length));
        const hexBytes = chunk.map(b => b.toString(16).padStart(2, '0').toUpperCase());

        // Pad with nbsp entities for alignment
        while (hexBytes.length < BYTES_PER_LINE) {
            hexBytes.push('&nbsp;&nbsp;');
        }

        const bytesStr = hexBytes.join(' ');
        const addr = (startOffset + i).toString(16).padStart(8, '0');
        chunks.push(`<span style="color: #569cd6;">0x${addr}: ${bytesStr}</span>`);
    }
    return chunks.join('\n');
}

// ===== End: textRenderer.js =====


/**
 * VirtualRenderer - Efficiently renders only visible records
 *
 * Only renders records in viewport + overscan buffer, dramatically improving
 * performance for large log files (100K+ events).
 */
class VirtualRenderer {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.records = [];
        this.visibleStart = 0;
        this.visibleEnd = 0;
        this.overscan = 100;  // Extra records above/below viewport

        // Height estimation (will be calibrated after first render)
        this.estimatedRowHeight = 20;  // Base height per record
        this.actualHeights = new Map();  // Track actual heights

        // DOM elements
        this.topSpacer = null;
        this.viewport = null;
        this.bottomSpacer = null;

        // Scroll state
        this.isUpdating = false;
        this.isProgrammaticScroll = false;
        this._scrollHandler = null;

        // Search state
        this.searchTerm = '';
        this.searchMatches = [];
        this.currentMatchIndex = -1;
    }

    /**
     * Initialize renderer with parsed log data
     */
    initialize(parsedData) {
        this.records = parsedData.records || [];
        this.setupContainer();

        // Calculate initial visible range
        this.updateVisibleRange();

        // If still no visible range (container not laid out yet), show first screen
        if (this.visibleEnd === 0) {
            this.visibleStart = 0;
            this.visibleEnd = Math.min(this.records.length, this.overscan * 2);
        }

        this.render();
    }

    /**
     * Setup container structure
     */
    setupContainer() {
        // Clear existing content
        this.container.innerHTML = '';

        // Create three-part structure: top spacer, viewport, bottom spacer
        this.topSpacer = document.createElement('div');
        this.topSpacer.style.height = '0px';

        this.viewport = document.createElement('div');
        this.viewport.className = 'virtual-viewport';

        this.bottomSpacer = document.createElement('div');
        this.bottomSpacer.style.height = '0px';

        this.container.appendChild(this.topSpacer);
        this.container.appendChild(this.viewport);
        this.container.appendChild(this.bottomSpacer);

        // Attach scroll listener to the container itself
        // Store bound handler for later removal if needed
        this._scrollHandler = this.onScroll.bind(this);
        this.container.addEventListener('scroll', this._scrollHandler);
    }

    /**
     * Handle scroll events with throttling
     */
    onScroll() {
        // Don't update if we're programmatically scrolling or already updating
        if (this.isProgrammaticScroll || this.isUpdating) return;

        this.isUpdating = true;

        // Use requestAnimationFrame for smooth updates
        requestAnimationFrame(() => {
            this.updateVisibleRange();
            this.isUpdating = false;
        });
    }

    /**
     * Calculate which records should be visible
     */
    updateVisibleRange() {
        if (!this.container) return;

        const scrollTop = this.container.scrollTop;
        const viewportHeight = this.container.clientHeight;

        // Estimate position based on average row height
        const estimatedStart = Math.floor(scrollTop / this.estimatedRowHeight);
        const estimatedEnd = Math.ceil((scrollTop + viewportHeight) / this.estimatedRowHeight);

        // Add overscan buffer
        const newStart = Math.max(0, estimatedStart - this.overscan);
        const newEnd = Math.min(this.records.length, estimatedEnd + this.overscan);

        // Only re-render if range changed significantly
        if (Math.abs(newStart - this.visibleStart) > 50 ||
            Math.abs(newEnd - this.visibleEnd) > 50) {
            this.visibleStart = newStart;
            this.visibleEnd = newEnd;
            this.render();
        }
    }

    /**
     * Render visible records
     */
    render() {
        if (this.records.length === 0) {
            this.viewport.innerHTML = '<div class="record">No records to display</div>';
            return;
        }

        // Render visible slice
        const html = [];
        for (let i = this.visibleStart; i < this.visibleEnd; i++) {
            const record = this.records[i];
            if (!record) {
                console.error('VirtualRenderer.render: Missing record at index', i);
                continue;
            }
            html.push(this.renderRecord(record, i));
        }

        this.viewport.innerHTML = html.join('');

        // Update spacer heights
        const topHeight = this.visibleStart * this.estimatedRowHeight;
        const bottomHeight = (this.records.length - this.visibleEnd) * this.estimatedRowHeight;

        this.topSpacer.style.height = `${topHeight}px`;
        this.bottomSpacer.style.height = `${bottomHeight}px`;

        // Apply search highlighting if active
        if (this.searchTerm) {
            this.highlightVisibleMatches();
        }
    }

    /**
     * Render a single record with binary data (always shown)
     */
    renderRecord(record, index) {
        if (record.binData && record.binData.length > 0) {
            const binLines = formatBinaryDataForRecord(record.binOffset, record.binData);
            const binLineArray = binLines.split('\n');

            // First line gets the record html appended
            let html = `<div class="record" data-index="${index}">${binLineArray[0]} ${record.html}</div>`;

            // Additional lines (for multi-byte events) are standalone
            for (let i = 1; i < binLineArray.length; i++) {
                html += `<div class="record" data-index="${index}">${binLineArray[i]}</div>`;
            }

            return html;
        } else {
            return `<div class="record" data-index="${index}">${record.html}</div>`;
        }
    }

    /**
     * Search through all records (in-memory, not DOM)
     */
    performSearch(searchTerm) {
        this.searchTerm = searchTerm;
        this.searchMatches = [];
        this.currentMatchIndex = -1;

        if (!searchTerm || searchTerm.length === 0) {
            this.render();  // Clear highlights
            return { matches: 0, current: -1 };
        }

        // Search through all records in memory
        const lowerSearch = searchTerm.toLowerCase();

        for (let i = 0; i < this.records.length; i++) {
            const record = this.records[i];
            // Strip HTML tags for text-only search
            const text = this.stripHtml(record.html).toLowerCase();
            if (text.includes(lowerSearch)) {
                this.searchMatches.push(i);
            }
        }

        if (this.searchMatches.length > 0) {
            this.currentMatchIndex = 0;
            // Scroll to first match and update viewport
            setTimeout(() => this.scrollToMatch(0), 50);
        } else {
            this.render();  // Re-render to clear any highlights
        }

        return {
            matches: this.searchMatches.length,
            current: this.currentMatchIndex
        };
    }

    /**
     * Navigate to next search match
     */
    searchNext() {
        if (this.searchMatches.length === 0) return { matches: 0, current: -1 };

        this.currentMatchIndex = (this.currentMatchIndex + 1) % this.searchMatches.length;

        // Scroll to match with small delay
        setTimeout(() => this.scrollToMatch(this.currentMatchIndex), 50);

        return {
            matches: this.searchMatches.length,
            current: this.currentMatchIndex
        };
    }

    /**
     * Navigate to previous search match
     */
    searchPrevious() {
        if (this.searchMatches.length === 0) return { matches: 0, current: -1 };

        this.currentMatchIndex = (this.currentMatchIndex - 1 + this.searchMatches.length) % this.searchMatches.length;

        // Scroll to match with small delay
        setTimeout(() => this.scrollToMatch(this.currentMatchIndex), 50);

        return {
            matches: this.searchMatches.length,
            current: this.currentMatchIndex
        };
    }

    /**
     * Scroll to a specific match
     */
    scrollToMatch(matchIndex) {
        if (matchIndex < 0 || matchIndex >= this.searchMatches.length) return;

        const recordIndex = this.searchMatches[matchIndex];
        if (!this.container) return;

        // Calculate scroll position
        const targetPosition = recordIndex * this.estimatedRowHeight;
        const viewportHeight = this.container.clientHeight;

        // Center the match in viewport
        const scrollTo = targetPosition - (viewportHeight / 2);

        // Set flag to prevent scroll handler from interfering
        this.isProgrammaticScroll = true;

        this.container.scrollTo({
            top: Math.max(0, scrollTo),
            behavior: 'smooth'
        });

        // Clear flag and force update after scroll animation
        setTimeout(() => {
            this.isProgrammaticScroll = false;
            this.updateVisibleRange();
            // Force re-render to apply highlights
            this.render();
        }, 300);
    }

    /**
     * Highlight search matches in visible records
     */
    highlightVisibleMatches() {
        if (!this.searchTerm) return;

        const records = this.viewport.querySelectorAll('.record');

        records.forEach(element => {
            const index = parseInt(element.dataset.index, 10);
            if (isNaN(index)) return;

            if (this.searchMatches.includes(index)) {
                const isCurrent = (index === this.searchMatches[this.currentMatchIndex]);
                this.highlightTextNodes(element, this.searchTerm, isCurrent);
            }
        });
    }

    /**
     * Highlight text nodes within an element
     */
    highlightTextNodes(element, searchTerm, isCurrent) {
        const highlightClass = isCurrent ? 'search-highlight-current' : 'search-highlight';
        const searchRegex = new RegExp(`(${this.escapeRegExp(searchTerm)})`, 'gi');

        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            null,
            false
        );

        const nodesToReplace = [];
        let node;

        while (node = walker.nextNode()) {
            if (searchRegex.test(node.textContent)) {
                nodesToReplace.push(node);
            }
        }

        nodesToReplace.forEach(textNode => {
            const text = textNode.textContent;
            const fragment = document.createDocumentFragment();
            let lastIndex = 0;
            const regex = new RegExp(this.escapeRegExp(searchTerm), 'gi');
            let match;

            while ((match = regex.exec(text)) !== null) {
                if (match.index > lastIndex) {
                    fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
                }

                const mark = document.createElement('mark');
                mark.className = highlightClass;
                mark.textContent = match[0];
                fragment.appendChild(mark);

                lastIndex = regex.lastIndex;
            }

            if (lastIndex < text.length) {
                fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
            }

            textNode.parentNode.replaceChild(fragment, textNode);
        });
    }

    /**
     * Strip HTML tags from string
     */
    stripHtml(html) {
        const div = document.createElement('div');
        div.innerHTML = html;
        return div.textContent || div.innerText || '';
    }

    /**
     * Escape special regex characters
     */
    escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    /**
     * Get total record count
     */
    getRecordCount() {
        return this.records.length;
    }

    /**
     * Clear all data
     */
    clear() {
        this.records = [];
        this.visibleStart = 0;
        this.visibleEnd = 0;
        this.searchTerm = '';
        this.searchMatches = [];
        this.currentMatchIndex = -1;

        if (this.container) {
            this.container.innerHTML = '';
        }
    }
}

// ===== End: js/virtualRenderer.js =====

// ===== Bundled: js/search.js =====
// search.js - Text search with highlighting
// NOTE: This module is now a thin wrapper around VirtualRenderer's search functionality

// Global reference to virtual renderer (set by index.html)
let _virtualRenderer = null;

/**
 * Set the virtual renderer instance
 */
function setVirtualRenderer(renderer) {
    _virtualRenderer = renderer;
}

/**
 * Perform search through log records
 * @param {string} searchTerm - Search query
 */
function performSearch(searchTerm) {
    if (!_virtualRenderer) {
        console.error('Virtual renderer not initialized');
        return;
    }

    const result = _virtualRenderer.performSearch(searchTerm);
    updateSearchUI(result);
}

/**
 * Navigate to next search match
 */
function searchNext() {
    if (!_virtualRenderer) return;

    const result = _virtualRenderer.searchNext();
    updateSearchUI(result);
}

/**
 * Navigate to previous search match
 */
function searchPrevious() {
    if (!_virtualRenderer) return;

    const result = _virtualRenderer.searchPrevious();
    updateSearchUI(result);
}

/**
 * Clear current search
 */
function clearSearch() {
    document.getElementById('searchInput').value = '';
    performSearch('');
}

/**
 * Get last search term (for re-applying after re-render)
 */
function getLastSearchTerm() {
    return _virtualRenderer ? _virtualRenderer.searchTerm : '';
}

// Private helper function
function updateSearchUI(result) {
    if (!result) {
        result = { matches: 0, current: -1 };
    }

    const hasResults = result.matches > 0;
    const hasSearch = _virtualRenderer && _virtualRenderer.searchTerm.length > 0;

    document.getElementById('searchPrevBtn').disabled = !hasResults;
    document.getElementById('searchNextBtn').disabled = !hasResults;
    document.getElementById('searchClearBtn').style.display = hasSearch ? 'block' : 'none';

    const countSpan = document.getElementById('searchCount');
    if (hasResults) {
        countSpan.textContent = `${result.current + 1}/${result.matches}`;
    } else if (hasSearch) {
        countSpan.textContent = 'No matches';
    } else {
        countSpan.textContent = '';
    }
}

// ===== End: js/search.js =====

// ===== Bundled: js/fileManager.js =====
// fileManager.js - File I/O and recent files management

const MAX_RECENT_FILES = 10;

/**
 * Get recent files from localStorage
 * @returns {Array} Array of recent file objects
 */
function getRecentFiles() {
    const stored = localStorage.getItem('recentFiles');
    return stored ? JSON.parse(stored) : [];
}

/**
 * Save recent file to localStorage
 * @param {Object} fileInfo - File information {name, size, timestamp}
 */
function saveRecentFile(fileInfo) {
    let recent = getRecentFiles();

    // Remove if already exists
    recent = recent.filter(f => f.name !== fileInfo.name);

    // Add to front
    recent.unshift(fileInfo);

    // Keep only MAX_RECENT_FILES
    if (recent.length > MAX_RECENT_FILES) {
        recent = recent.slice(0, MAX_RECENT_FILES);
    }

    localStorage.setItem('recentFiles', JSON.stringify(recent));
}

/**
 * Clear all recent files
 */
function clearRecentFiles() {
    localStorage.removeItem('recentFiles');
}

/**
 * Read file as Uint8Array
 * @param {File} file - File object from input
 * @returns {Promise<Uint8Array>} File data
 */
function readFileAsUint8Array(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();

        reader.onload = (e) => {
            resolve(new Uint8Array(e.target.result));
        };

        reader.onerror = (e) => {
            reject(new Error('Failed to read file'));
        };

        reader.readAsArrayBuffer(file);
    });
}

/**
 * Format bytes to human-readable string
 * @param {number} bytes - Number of bytes
 * @returns {string} Formatted string (e.g., "1.5 MB")
 */
function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}

// ===== End: js/fileManager.js =====


        // Global state
        let currentParsedData = null;
        let virtualRenderer = null;

        // Make functions globally accessible for onclick handlers
        window.handleFile = handleFile;
        window.toggleRecentFiles = toggleRecentFiles;
        window.clearLog = clearLog;
        window.switchTab = switchTab;
        window.handleSearchKeyup = handleSearchKeyup;
        window.handleSearchNext = () => searchNext();
        window.handleSearchPrevious = () => searchPrevious();
        window.handleClearSearch = () => clearSearch();

        // File handling
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            console.log('handleFile called with:', file.name, file.size);
            const startTime = performance.now();

            // Show progress overlay
            const overlay = document.getElementById('progressOverlay');
            const progressText = document.getElementById('progressText');
            const progressBar = document.getElementById('progressBar');
            const progressStatus = document.getElementById('progressStatus');

            overlay.style.display = 'flex';
            progressText.textContent = 'Reading file...';
            progressBar.style.width = '10%';
            progressStatus.textContent = '10%';

            try {
                console.log('Reading file as Uint8Array...');
                const data = await readFileAsUint8Array(file);
                console.log('File read complete:', data.length, 'bytes');

                progressText.textContent = 'Parsing log data...';
                progressBar.style.width = '30%';
                progressStatus.textContent = '30%';

                // Allow UI to update
                await new Promise(resolve => setTimeout(resolve, 50));

                console.log('Parsing log...');
                const result = parseLog(data);
                console.log('Parse complete:', result.recordCount, 'events');
                const processingTime = (performance.now() - startTime) / 1000;

                progressText.textContent = 'Rendering output...';
                progressBar.style.width = '60%';
                progressStatus.textContent = '60%';

                // Store parsed data
                currentParsedData = result;

                // Save to recent files
                saveRecentFile({
                    name: file.name,
                    size: data.length,
                    timestamp: Date.now()
                });

                // Update stats
                document.getElementById('statFileSize').textContent = formatBytes(data.length);
                document.getElementById('statEvents').textContent = result.recordCount.toLocaleString();
                document.getElementById('statDuration').textContent = result.duration.toFixed(2) + 's';
                document.getElementById('statProcessTime').textContent = processingTime.toFixed(2) + 's';

                progressBar.style.width = '80%';
                progressStatus.textContent = '80%';

                // Initialize virtual renderer
                if (!virtualRenderer) {
                    virtualRenderer = new VirtualRenderer('textOutput');
                    setVirtualRenderer(virtualRenderer);
                }
                virtualRenderer.initialize(result);

                progressBar.style.width = '100%';
                progressStatus.textContent = '100%';

                // Update UI
                document.getElementById('dropZone').style.display = 'none';
                document.getElementById('tabsContainer').style.display = 'flex';
                document.getElementById('clearBtn').disabled = false;
                document.getElementById('fileInfo').textContent = `${file.name} (${formatBytes(data.length)})`;

                console.log('All done!');

                // Hide progress after a short delay
                setTimeout(() => {
                    overlay.style.display = 'none';
                    progressBar.style.width = '0%';
                }, 500);

            } catch (err) {
                console.error('Error parsing log:', err);
                console.error('Stack trace:', err.stack);
                overlay.style.display = 'none';
                document.getElementById('textOutput').innerHTML = `<div class="error">Error parsing log: ${err.message}<br><br>Check browser console for details.</div>`;
                document.getElementById('dropZone').style.display = 'none';
                document.getElementById('tabsContainer').style.display = 'flex';
            }
        }

        function handleSearchKeyup(event) {
            if (event.key === 'Enter') {
                if (event.shiftKey) {
                    searchPrevious();
                } else {
                    searchNext();
                }
            } else {
                const searchTerm = document.getElementById('searchInput').value;
                performSearch(searchTerm);
            }
        }

        function toggleRecentFiles() {
            const panel = document.getElementById('recentFilesPanel');
            const isVisible = panel.style.display !== 'none';

            if (isVisible) {
                panel.style.display = 'none';
            } else {
                updateRecentFilesList();
                panel.style.display = 'block';
            }
        }

        function updateRecentFilesList() {
            const files = getRecentFiles();
            const listDiv = document.getElementById('recentFilesList');

            if (files.length === 0) {
                listDiv.innerHTML = '<p style="color: #6c757d;">No recent files</p>';
                return;
            }

            listDiv.innerHTML = files.map(f => `
                <div style="padding: 10px; margin-bottom: 10px; background: white; border-radius: 5px; cursor: pointer;"
                     onclick="alert('Recent file selection not yet implemented')">
                    <strong>${f.name}</strong>
                    <div style="font-size: 12px; color: #666;">
                        ${formatBytes(f.size)} ‚Ä¢ ${new Date(f.timestamp).toLocaleString()}
                    </div>
                </div>
            `).join('');
        }

        function clearLog() {
            if (virtualRenderer) {
                virtualRenderer.clear();
            }
            document.getElementById('dropZone').style.display = 'flex';
            document.getElementById('tabsContainer').style.display = 'none';
            document.getElementById('fileInfo').textContent = '';
            document.getElementById('clearBtn').disabled = true;
            document.getElementById('fileInput').value = '';
            document.getElementById('searchInput').value = '';
            currentParsedData = null;
            clearSearch();
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.dataset.tab === tabName);
            });
        }

        // Drag and drop
        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#667eea';
            dropZone.style.background = '#f8f9fa';
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.style.borderColor = '#cbd5e0';
            dropZone.style.background = 'white';
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#cbd5e0';
            dropZone.style.background = 'white';

            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        dropZone.addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
    
    </script>
</body>
</html>
